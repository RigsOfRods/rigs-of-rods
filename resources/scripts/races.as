/*
Hi,

You've found your way to the race system of Rigs of Rods.

If you are looking for more information on how to use this
class or what arguments should be given to certain functions,
please visit http://docs.rigsofrods.org/

If you are looking for examples on how to use this class,
please look at the scripting files of other terrains or
search the forum.

If you have questions that cannot be answerred using the
methods mentioned above, then please ask your question in
the scripting section of the Rigs of Rods forum:
http://www.rigsofrods.org/forums/167-Scripting

This class was designed to be as simple as possible for
normal users, while being as flexible as possible for
advanced users.
If you're here because this class doesn't provide the
functionality that you need for your terrain, then try
to improve the class and submit your additions using
the issue tracker of Rigs of Rods.
http://redmine.rigsofrods.org

Don't forget to increase the version numbers after every
edit! (racesManager::raceManagerVersion and
raceBuilder::raceBuilderVersion)

-- neorej16
*/

#include "genericdoc_utils.as"

// Define a function signature for the callback pointers
funcdef void RACE_EVENT_CALLBACK(dictionary@);

// called when a vehicle is in a checkpoint
void raceEvent(int trigger_type, string inst, string box, int nodeid, int eventTruckNum) {
	races.raceEvent(trigger_type, inst, box, nodeid, eventTruckNum);
}

void raceCancelPointHandler(int trigger_type, string inst, string box, int nodeid) {
	races.raceCancelPointHandler(trigger_type, inst, box, nodeid);
}

// This is a simple wrapper for the raceList to allow array style indexing in the dictionary
// This is so the raceID can be any number, pregenerated by the C++ (to be implemented ChampionshipManager), without breaking existing scripts.
// marked 'shared' so that other scripts can access the race data using `game.getScriptVariable()`
shared class raceDictionary {
// public functions
// constructor
    raceDictionary() {
        this.raceCount = 0;
    }
//Overloads for []
    raceBuilder@ get_opIndex(int idx) const property {        
        raceBuilder @builder;
        string key = formatInt(idx);
        int raceIndex;
        if (this.dict.get(key, raceIndex) && raceIndex < this.raceCount)
            return raceList[raceIndex];
        return null;
    }
    void set_opIndex(int idx, raceBuilder @value) property {
        string key = formatInt(idx);
        //TODO maybe just put an array index in here and keep the object in an array?
        int raceIndex = this.getNewRaceIndex();
        this.raceList.resize(this.raceCount);
        @raceList[raceIndex] = @value;
        this.dict.set(key, raceIndex);
    }
	int getNewRaceIndex()
	{
		// try to recycle a race Index
		for( int i = 0; i < this.raceCount; i++ )
		{
			if( this.raceList[i].awaitingRecycling )
				return i;
		}
		return this.raceCount++;
	}    
    void resize(int count ) {
        //do nothing - this is for backwards compatibility only!
    }
// private properties
    dictionary dict;
    array<raceBuilder@> raceList;
    int raceCount;
}

// This class will handle the race logic for you
// this class shouldn't be edited!
// marked 'shared' so that other scripts can access the race data using `game.getScriptVariable()`
shared class racesManager {
// public properties
	int raceCount;
	int currentRace;
	int currentLap;
	int truckNum;
	int lastCheckpoint;
	bool obligatedFinish;
	bool showTimeDiff;
	bool showBestLap;
	bool showBestRace;
	bool submitScore;
	bool showCheckPointInfoWhenNotInRace;
	bool silentMode;
	bool allowVehicleChanging;
	bool abortOnVehicleExit;
	bool restartRaceOnStart;
	bool penaltyGiven;
	int actionOnTruckExit;
	int state;
	int cancelPointCount;
	double raceStartTime;
	double lapStartTime;
	string lastCheckpointInstance;
	string lastRaceEventInstance;
	double lastRaceEventTime;
	string raceManagerVersion;
	int arrowMethod;
	LocalStorageClass@ raceDataFile;
	array<int> penaltyTime;

// public constants
	int LAPS_Unlimited;
	int LAPS_NoLaps;
	int LAPS_One;

	int ACTION_DoNothing;
	int ACTION_SuspendRace;
	int ACTION_StopRace;
	int ACTION_RestartRace;

	int STATE_NotInRace;
	int STATE_Waiting;
	int STATE_Racing;
	int STATE_Finished;

	int ARROW_AUTO;

	double AI_CheckpointTimeout;
		
// private properties
	array<raceBuilder@> raceList; //Changed this to use a dictionary so we can change the IDs to pregenerated ones from ChampionshipManager
    raceDictionary raceDict;
	dictionary callbacks;
	dictionary competitors;//List of trucks in the current race(s) with their individual times and stats.
	int minTruckNum;//Minimum truckNum added to competitors
	int maxTruckNum;//Max truckNum added to competitors
	int numCompetitors;

// public functions

	// constructor
	racesManager() {

		// We initialize our "constants"
		this.LAPS_Unlimited = -1;
		this.LAPS_NoLaps = 0;
		this.LAPS_One = 1;

		this.ACTION_DoNothing   = 0;
		this.ACTION_SuspendRace = 1;
		this.ACTION_StopRace    = 2;
		this.ACTION_RestartRace = 3;

		this.STATE_NotInRace = 0;
		this.STATE_Waiting   = 1;
		this.STATE_Racing    = 2;
		this.STATE_Finished  = 3;

		this.ARROW_AUTO = -1;

		this.AI_CheckpointTimeout = 50.0; // If an AI in the race takes longer than this between two checkpoints, the race can be ended
				
		// we initialize the callbacks dictionary
		this.callbacks.set("RaceFinish", null); // when a race was finished
		this.callbacks.set("RaceCancel", null); // when a race was canceled
		this.callbacks.set("RaceStart",  null); // when a race starts
		this.callbacks.set("AdvanceLap", null); // when a lap is done, but not when the race is done
		this.callbacks.set("Checkpoint", null); // when a checkpoint is taken (excluding start and finish)
		this.callbacks.set("NewBestLap", null); // When a new best lap time is set
		this.callbacks.set("NewBestRace", null);// When a new best race time is set
		this.callbacks.set("LockedRace", null); // When the user passes the start line of a locked race
		this.callbacks.set("RaceEvent", null); // When the user passes the start line of a locked race
		this.callbacks.set("PenaltyEvent", null); // When the user gets in a race_penalty box, handled by the raceEvent method
		this.callbacks.set("AbortEvent", null); // When the user gets in a race_abort box, handled by the raceEvent method

		// initialize the default settings
		this.obligatedFinish   = false; // if true: if you drive through the start checkpoint of another race, while racing, it will be ignored
		this.showTimeDiff      = true;  // if true: Show + or - <best time minus current time> when passing a checkpoint.
		this.showBestLap       = true;  // if true: If a race is started or a new best lap is set, the best lap will be shown
		this.showBestRace      = true;  // if true: If a race is started or a new best race is set, the best race will be shown
		this.submitScore       = true; // if true: If the user has a new best lap or new best race, this is submitted to the master server.
		this.silentMode        = false; // if true: No messages will be shown
		this.allowVehicleChanging = false; // if false: if the user changes vehicle, the race will be aborted.
		this.abortOnVehicleExit = false;  // if true: if the user exits his vehicle, the race will be aborted
		this.showCheckPointInfoWhenNotInRace = false; // if true: if the user drives through a checkpoint of a race that isn't running, a message will be shown, saying "this is checkpoint xx of race myRaceName"
		this.arrowMethod       = this.ARROW_AUTO;
		this.restartRaceOnStart = true; // if true: the race will be restarted when you pass the start line of the same race

		// we initialize the other variables (do not edit these manually)
		this.state           = this.STATE_NotInRace;
		this.raceCount       = 0;
		this.currentRace     = -1;
		this.lastCheckpoint  = -1;
		this.raceStartTime   = 0.0;
		this.lapStartTime    = 0.0;
		this.cancelPointCount= 0;
		this.lastCheckpointInstance = "";
		this.lastRaceEventInstance = ""; // we only use this to boost the FPS
		this.raceManagerVersion = "RoR_raceManager_v0.03";
		this.penaltyGiven = true;
		this.truckNum = -1;
		this.minTruckNum = 0;
		this.maxTruckNum = -1;
		this.numCompetitors = 0;

		// register the required callbacks
		game.registerForEvent(SE_TRUCK_ENTER);
		game.registerForEvent(SE_TRUCK_EXIT);
		game.registerForEvent(SE_TRUCK_RESET);
		game.registerForEvent(SE_TRUCK_TELEPORT);
        game.registerForEvent(SE_TRUCK_MOUSE_GRAB);
		game.registerForEvent(SE_GENERIC_DELETED_TRUCK);
		game.registerForEvent(SE_ANGELSCRIPT_MANIPULATIONS);

		// add the eventcallback method if it doesn't exist
		// ^ but only if loaded from terrain script, not i.e. terrain_project_importer
		dictionary@ scriptDetails = game.getScriptDetails(thisScript);
		if (@scriptDetails != null
			&& ScriptCategory(scriptDetails['scriptCategory']) == SCRIPT_CATEGORY_TERRAIN)
		{
			if( game.scriptFunctionExists("void eventCallback(int, int)")<0)
			{
				game.addScriptFunction("void eventCallback(int key, int value) { races.eventCallback(key, value); }");
			}
		}

		// Load the file containing the race data
		@this.raceDataFile = LocalStorageClass("raceTimes");
	}

	// Processes the new 'race-def' files generated by project importer, see new terrn2 section [Races]. Returns number of checkpoints or negative number on error.
	int addRaceFromDefinitionFile(string filename, string resourceGroup)
	{
		GenericDocumentClass doc;
		if (!doc.loadFromResource(filename, resourceGroup, genericdoc_utils::FLAGSET_RACE))
		{
			game.log("Error in racesManager::addRaceFromDefinitionFile: could not load race-def file.");
			return -1;
		}

		int raceID = this.addNewEmptyRace();

		GenericDocContextClass@ ctx = GenericDocContextClass(doc);
		bool inCheckpoints = false;
		array<uint> checkpointTokPositions; // We must pre-count checkpoints to pick finish-obj correctly.
		int highestCheckpointNum = 0; // Multiple finish lines are supported!
		while (!ctx.endOfFile())
		{
			//game.log("DBG addRaceFromDefinitionFile() token "+genericdoc_utils::tokenTypeStr(ctx.tokenType())+" at pos "+ctx.getPos());

			if (ctx.isTokKeyword(0))
			{
				if (ctx.isTokString(1) && ctx.getTokKeyword() == "race_name")
				{
					this.raceList[raceID].raceName = ctx.getTokString(1);
				}
				if (ctx.isTokInt(1) && ctx.getTokKeyword() == "race_laps")
				{
					this.raceList[raceID].setLaps(ctx.getTokInt(1));
				}
				else if (ctx.isTokString(1) && ctx.getTokKeyword() == "race_checkpoint_object")
				{
					this.raceList[raceID].objNameCheckpoint = ctx.getTokString(1);
				}
				else if (ctx.isTokString(1) && ctx.getTokKeyword() == "race_start_object")
				{
					this.raceList[raceID].objNameStart = ctx.getTokString(1);
				}
				else if (ctx.isTokString(1) && ctx.getTokKeyword() == "race_finish_object")
				{
					this.raceList[raceID].objNameFinish = ctx.getTokString(1);
				}
				else if (ctx.getTokKeyword() == "begin_checkpoints")
				{
					inCheckpoints = true;
				}
				else if (ctx.getTokKeyword() == "end_checkpoints")
				{
					inCheckpoints = false;
				}
			}
			else if (inCheckpoints)
			{
				//game.log("DBG inCheckpoints | isTok*:  "+ctx.isTokInt(0) +" "+ctx.isTokInt(1) // chkpNum, altpathNum
				//	+" "+ ctx.isTokFloat(2) +" "+ ctx.isTokFloat(3) +" "+ ctx.isTokFloat(4) // Pos XYZ
				//	+" "+ ctx.isTokFloat(5) +" "+ ctx.isTokFloat(6) +" "+ ctx.isTokFloat(7)); // Rot XYZ
				//
				//game.log("DBG inCheckpoints | tokType:  "
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(0))
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(1)) // chkpNum, altpathNum
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(2))
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(3))
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(4)) // Pos XYZ
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(5))
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(6))
				//	+" "+ genericdoc_utils::tokenTypeStr(ctx.tokenType(7))); // Rot XYZ

				if (ctx.isTokInt(0) && ctx.isTokInt(1) // chkpNum, altpathNum
					&& ctx.isTokFloat(2) && ctx.isTokFloat(3) && ctx.isTokFloat(4) // Pos XYZ
					&& ctx.isTokFloat(5) && ctx.isTokFloat(6) && ctx.isTokFloat(7)) // Rot XYZ
				{
					highestCheckpointNum = (ctx.getTokInt() > highestCheckpointNum) ? ctx.getTokInt() : highestCheckpointNum;
					checkpointTokPositions.insertLast(ctx.getPos());
				}
			}
			ctx.seekNextLine();
		}

		// check input
		if( highestCheckpointNum < 2 )
		{
			game.log("Error in racesManager::addRaceFromDefinitionFile: A race should have at least 2 checkpoints.");
			return -3;
		}

		// Reset context and process pre-counted checkpoints
		@ctx = GenericDocContextClass(doc);
		for (uint i = 0; i < checkpointTokPositions.length(); i++)
		{
			// Seek to checkpoint
			while (ctx.getPos() < checkpointTokPositions[i])
				ctx.moveNext();

			// Decide object
			string objName = this.raceList[raceID].objNameCheckpoint;
			if (ctx.isTokString(8))
				objName = ctx.getTokString(8); // override
			else if (ctx.getTokInt() == 1)
				objName = this.raceList[raceID].objNameStart;
			else if (ctx.getTokInt() == highestCheckpointNum)
				objName = this.raceList[raceID].objNameFinish;

			// Submit checkpoint
			const double[] v = { ctx.getTokFloat(2), ctx.getTokFloat(3), ctx.getTokFloat(4), ctx.getTokFloat(5), ctx.getTokFloat(6), ctx.getTokFloat(7) };
			this.raceList[raceID].addCheckpoint(ctx.getTokInt(0)-1, objName, v);
		}

		return highestCheckpointNum;
	}

	// Processes files under new terrn2 section [Races], returns number of races added or negative number on error.
	int loadRacesFromTerrn2()
	{
		TerrainClass@ terrain = game.getTerrain();
		if (@terrain == null)
		{
			game.log("Error in racesManager::loadRacesFromTerrn2: no terrain loaded.");
			return -1;
		}

		GenericDocumentClass doc;
		if (!doc.loadFromResource(terrain.getTerrainFileName(), terrain.getTerrainFileResourceGroup(), genericdoc_utils::FLAGSET_TERRN2))
		{
			game.log("Error in racesManager::loadRacesFromTerrn2: could not load terrn2 file.");
			return -2;
		}

		GenericDocContextClass ctx(doc);
		while (!ctx.endOfFile() && (!ctx.isTokKeyword() || ctx.getTokKeyword() != "[Races]"))
		{
			ctx.seekNextLine();
		}
		//game.log("DBG [Races] tokenPos:" + ctx.getPos() + ", EOF:" + ctx.endOfFile());
		ctx.seekNextLine();
		//game.log("DBG next line: tokenType:" + genericdoc_utils::tokenTypeStr(ctx.tokenType()));

		const string BRACKET="[";
		const string EQUALS="=";
		int numRaces = 0;
		while (!ctx.endOfFile() && (!ctx.isTokKeyword() || ctx.getTokKeyword()[0]!=BRACKET[0]))
		{
			string filename = ctx.getTokString();
			//game.log("DBG [Races] filename " + filename + " at pos " + ctx.getPos());
			// Cut off the mandatory '='
			if (filename[filename.length() - 1] == EQUALS[0])
			{
				filename = filename.substr(0, filename.length() - 1);
			}
			if (this.addRaceFromDefinitionFile(filename, terrain.getTerrainFileResourceGroup()) > 0)
			{
				numRaces++;
			}
			ctx.seekNextLine();
		}

		return numRaces;
	}

	// add a race
	//  pre: nothing
	// post: A new race was added and built
	int addRace(const string &in raceName, const double[][] &in checkpoints, int laps = 0, const string &in objName_checkpoint = "chp-checkpoint", const string &in objName_start = "chp-start", const string &in objName_finish = "chp-start", const string &in version = "unknown")
	{
		// debug: game.log("racesManager::addRace(\"" + raceName + "\", \"" + objName_start + "\", \"" + objName_checkpoint + "\", \"" + objName_finish + "\", checkpoints, loop) called.");
				
		// check input
		if( checkpoints.length() < 2 )
		{
			game.log("Error in racesManager::addRace: A race should have at least 2 checkpoints.");
			return -1;
		}
		
		int raceID;                
		string terrain;
		game.getLoadedTerrain(terrain);
		//Old pure angelscript method, ignores the championshipManager
		raceID = this.getNewRaceID();
		//raceID = championshipManager.allocateRaceID(terrain, raceName);
		@this.raceDict[raceID] = @raceBuilder(raceID);
		if (raceID < 1000 and raceID >= this.raceCount)
		{
			this.raceCount = raceID + 1;
			this.raceList.resize(this.raceCount);
			@this.raceList[raceID] = @raceBuilder(raceID);
			this.raceList[raceID].raceName = raceName;
			this.raceList[raceID].setLaps(laps);
			this.raceList[raceID].addChpCoordinates(checkpoints, objName_checkpoint, objName_start, objName_finish, 0);
			this.setVersion(raceID, version);
			this.raceList[raceID].loadRace(@this.raceDataFile);
		}

		this.raceDict.resize(this.raceCount);
		@this.raceDict[raceID] = @raceBuilder(raceID);
		this.raceDict[raceID].raceName = raceName;
		this.raceDict[raceID].setLaps(laps);
		this.raceDict[raceID].addChpCoordinates(checkpoints, objName_checkpoint, objName_start, objName_finish, 0);
		this.raceDict[raceID].setVersion(version); //this.setVersion(raceID, version);
		this.raceDict[raceID].loadRace(@this.raceDataFile);

		return raceID;
	}

	// Advanced users only
	int addNewEmptyRace()
	{
		int raceID = this.getNewRaceID();
		this.raceList.resize(this.raceCount);
		@this.raceList[raceID] = @raceBuilder(raceID);
		
		this.raceDict.resize(this.raceCount);
		@this.raceDict[raceID] = @raceBuilder(raceID);

		return raceID;
	}

	int getNewRaceID()
	{
		// try to recycle a race ID
		int len = this.raceList.length();
		for( int i = 0; i < len; i++ )
		{
			if (this.raceDict[i].awaitingRecycling)
				return i;
			if( this.raceList[i].awaitingRecycling )
				return i;
		}
		return this.raceCount++;
	}

	//  pre: nothing
	// post: A callback function has been registered
	void setCallback(const string &in event, RACE_EVENT_CALLBACK @func)
	{
		if( not callbacks.exists(event) )
			game.log("Error in racesManager::setCallback: Event '" + event + "' does not exist.");
		callbacks.set(event, @func);
	}

	// I don't immediately see a use for this function, but maybe someone will come up with a use for it
	RACE_EVENT_CALLBACK@ getCallback(const string &in event)
	{
		RACE_EVENT_CALLBACK @func;
		if( callbacks.get(event, @func) )
			return @func;
		return null;
	}

	//  pre: nothing
	// post: The callback unregistered
	void removeCallback(const string &in event)
	{
		if( not callbacks.exists(event) )
			game.log("Error in racesManager::removeCallback: Event '" + event + "' does not exist.");
		callbacks.set(event, null);
	}

	//You need to call this regularly, for example from frameStep() to keep the race position on the overlay updated
	//otherwise the positions will only update at race checkpoints
	void raceUpatePositions()
	{
		if (this.currentRace >= 0)
		{
			this.calcPositions(this.currentRace);
		}
	}

	bool canEndActiveRace(bool waitForThePlayer)
	{
		//NOW if someone won the race, TODO see the time they did it
		//and look for stuck vehicles a lap down or after a time limit.
		//If they have inactive AI as well they may be stuck.
		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			if (this.competitors.get(formatInt(i, ''), @c) and !(c is null) and c.currentRace >= 0)
			{
				if (c.state == STATE_Racing)
				{
					if (c.isThePlayer and waitForThePlayer)
					{
						game.log("Cannot end active race because the Player is still racing.");
						return false;
					}
					//The commented out code was to see if they're more than a lap down after the leader finished the race
					//but bots have a tendency to get stuck even on the last lap, so we just use a checkpoint timeout instead.
					//if ((c.currentLap < this.raceDict[c.currentRace].laps) and (this.raceDict[c.currentRace].laps != this.LAPS_Unlimited))
					{
						if (c.hasAI)
						{
							double time = game.getTime();
							if (c.lastCheckpointTime > 0.0)
							{
								time = time - c.lastCheckpointTime;
							}
							else if (c.lapStartTime > 0.0)
							{
								time = time - c.lapStartTime;
							}
							else
							{
								time = 0.0;
							}
							if (time > this.AI_CheckpointTimeout)
							{
								continue;
							}
						}
					}
					return false;
				}
			}
		}
		return true;
	}
	
	// This will get called when a truck is at a checkpoint
	// You shouldn't call this manually (use the callback instead)
	void raceEvent(int trigger_type, string inst, const string &in box, int nodeid, int eventTruckNum)
	{
		// debug: game.log("racesManager::raceEvent(" + trigger_type + ", \"" + inst + "\", \"" + box + "\", " + nodeid + ", " + eventTruckNum + ") called.");
		
		//First see which truck triggered the event.
		int curTruckNum = -1;
		//See if it's an AI truck or the player's one and write to competitor data as necessary
		racesCompetitor @competitor = null;
		
		if (eventTruckNum > -1)
		{
			if (not competitors.get(formatInt(eventTruckNum, ''), @competitor) or competitor is null)
			{
				@competitor = racesCompetitor(eventTruckNum);
				competitors.set(formatInt(eventTruckNum, ''), @competitor);
				if (eventTruckNum < minTruckNum)
				{
					minTruckNum = eventTruckNum;
				}
				if (eventTruckNum > maxTruckNum)
				{
					maxTruckNum = eventTruckNum;
				}
				numCompetitors++;
			}
			//BeamClass @eventTruck = game.getTruckByNum(eventTruckNum);
			VehicleAIClass @eventAI = game.getTruckAIByNum(eventTruckNum);
			competitor.hasAI = eventAI !is null;
			curTruckNum = game.getCurrentTruckNumber();
			//TODO need a better way to detect the player's vehicle (e.g. camera focus?)
			//This is NOT working with !(competitor.hasAI) || !eventAI.isActive() - AI cars that are waiting on the grid are being set as isThePlayer as well
			//Note that truck spawn finalize sets the spawned truck as the current if (local_truck->driveable != NOT_DRIVEABLE) which may be breaking this
			if (((not (competitor.hasAI)) or not (eventAI.isActive())) and (eventTruckNum == curTruckNum))
			{
				competitor.isThePlayer = true;
			}
			else
			{
				competitor.isThePlayer = false;
			}


			if (eventAI !is null and eventAI.isActive())
			{
				//this.message("ignoring AI truck for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
				//competitor.lastRaceEventInstance = inst;//this.lastRaceEventInstance = "";//inst;
				//return;
			}
		}
		else
		{
			game.log("raceEvent() called without a valid actor ID. Ignoring. Are you running an old version of the game?");
			return;
		}

/*		
		RaceClass@ champRace;
		if (championshipManager.hasCurrentRace())
		{
			@champRace = @championshipManager.getCurrentRace();
			if (champRace !is null and champRace.GetID() == competitor.currentRace and champRace.IsRunning() and competitor.currentLap > 0)
			{
				//Don't allow restarts of championship races or switching to a different race
				this.obligatedFinish = true;
				if (competitor.lastCheckpoint >= 0)
				{
					this.restartRaceOnStart = false;
				}
			}			
		}		
*/		
		if( box == "race_penalty" and !competitor.penaltyGiven and this.state == this.STATE_Racing )
		{
			// the inst string contains the information about the event
			array<string>@ tmp = inst.split("|");
			if( tmp.length() >= 3 )
			{
				int checkpointNum = parseInt(tmp[2]);
				int raceID        = parseInt(tmp[1]);
				if( raceID == competitor.currentRace or raceID == -1 )
				{
					//TODO make getPenaltyTime() handle competitors
					int penaltyTime = this.getPenaltyTime(raceID);

					// call the callback function
					RACE_EVENT_CALLBACK @handle;
					if( callbacks.get("PenaltyEvent", @handle) and (handle !is null))
					{
						dictionary args;
						args.set("event", "PenaltyEvent");
						args.set("raceID", raceID);
						args.set("checkpointNum", checkpointNum);
						args.set("trigger_type", trigger_type);
						args.set("inst", ""+inst);
						args.set("box", ""+box);
						args.set("nodeid", nodeid);
						args.set("penaltyTime", penaltyTime);
						handle(@args);
						args.get("penaltyTime", penaltyTime);
					}
					//TODO make this work with a competitor
					this.addPenaltySeconds(competitor, penaltyTime);
					competitor.penaltyGiven = true;
				}
			}
			return;
		}
		else if( box == "race_abort" and this.state == this.STATE_Racing )
		{
			// the inst string contains the information about the event
			array<string>@ tmp = inst.split("|");
			if( tmp.length() >= 3 )
			{
				int checkpointNum = parseInt(tmp[2]);
				int raceID        = parseInt(tmp[1]);
				if( raceID == competitor.currentRace or raceID == -1 )
				{

					// call the callback function
					RACE_EVENT_CALLBACK @handle;
					if( callbacks.get("AbortEvent", @handle) and not (handle is null))
					{
						dictionary args;
						args.set("event", "AbortEvent");
						args.set("raceID", raceID);
						args.set("checkpointNum", checkpointNum);
						args.set("trigger_type", trigger_type);
						args.set("inst", ""+inst);
						args.set("box", ""+box);
						args.set("nodeid", nodeid);
						args.set("break", false);
						handle(@args);
						bool result = false;
						args.get("break", result);
						if( result )
							return;
					}

					this.cancelCurrentRace();
				}
			}
			return;
		}

		// We don't want to handle the same checkpoint twice
		if( ( inst == competitor.lastRaceEventInstance ) )
			return;
		competitor.lastRaceEventInstance = inst;
		
		if (competitor.isThePlayer)
		{
			//this.message("set truckNum: "+eventTruckNum+" as the player (no active AI) curTruckNum when set: " + curTruckNum + " curTruckNum now: "+game.getCurrentTruckNumber(), "flag_orange.png");
		}

		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceEvent", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceEvent");
			args.set("raceID", -1);
			args.set("trigger_type", trigger_type);
			args.set("inst", ""+inst);
			args.set("box", ""+box);
			args.set("nodeid", nodeid);
			args.set("break", false);
			handle(@args);
			bool result = false;
			args.get("break", result);
			if( result )
				return;
		}

		// the inst string contains the information about the checkpoint
		array<string>@ tmp = inst.split("|");
		if( tmp.length() >= 3 and (tmp[0] == "checkpoint") )
		{
			int checkpointNum = parseInt(tmp[2]);
			int raceID        = parseInt(tmp[1]);

			if( checkpointNum == competitor.lastCheckpoint )
				return;
			else if(competitor.state != STATE_Racing)
			{
				// we're not racing, but maybe we passed the start line?
				if(checkpointNum == 0)
				{
					// yes! We passed the start line, so we'll start the race!
					// But we only start the race if they're not already racing, or the player can start a new race now
					bool canStart = false;
					bool hasStartedThisRace = this.raceDict[raceID].entrants.find(competitor.truckNum) >= 0;
					if (competitor.lastRace == -1 && !competitor.isThePlayer && !hasStartedThisRace)
					{
						// A bot crossing the line will join any existing race, or start a new one if none is running
						canStart = true;
					}
					if (competitor.isThePlayer)
					{
						if (!hasStartedThisRace)
						{
							// The player can join the existing race
							canStart = true;
							if (this.raceStartTime > 0) this.message("You are joining active race "+this.raceDict[raceID].raceName+"!", "tick.png");
						}
						else if (canEndActiveRace(false))
						{
							//The player can end the existing race and start a new one
							cancelCurrentRace();
							canStart = true;
							this.message("Active race "+this.raceDict[raceID].raceName+" canceled so new one can start.", "tick.png");
						}
						else
							this.message("1 or more vehicles are still racing in "+this.raceDict[raceID].raceName+"!", "cross.png");
					}
					if (canStart)
					{
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						this.startRace(raceID, competitor);
					}
				}
				else if( this.showCheckPointInfoWhenNotInRace and competitor.isThePlayer)
				{
					// passed some not-start checkpoint
					this.message("This is checkpoint "+checkpointNum+" of race "+this.raceDict[raceID].raceName+"!", "tick.png");
				}
			}
			else if(competitor.state == STATE_Racing and competitor.currentRace == raceID)
			{
				// we hit a checkpoint from the same race!
				if( checkpointNum == this.raceDict[raceID].finishNum and this.raceDict[raceID].finishNum == this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint))
				{ // passing the finishline
					//this.message("Number " + competitor.truckNum + " passed the finish line!", "flag_green.png");
					if( (competitor.currentLap < this.raceDict[raceID].laps) or (this.raceDict[raceID].laps == this.LAPS_Unlimited) )
					{
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						if (competitor.isThePlayer)
							game.log("You completed lap " + competitor.currentLap + ".");
						else
							game.log("Number " + competitor.truckNum + " completed lap " + competitor.currentLap + ".");
						this.advanceLap(competitor);
						calcPositions(raceID);
					}
					else if( (competitor.currentLap >= this.raceDict[raceID].laps) or (this.raceDict[raceID].laps == this.LAPS_NoLaps) )
					{
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						if (competitor.isThePlayer)
						{
							this.message("You finished the race!", "flag_green.png");
							//game.log("You finished the race!");
						}
						else
						{
							this.message("Number " + competitor.truckNum + " finished the race!", "flag_green.png");
							//game.log("Number " + competitor.truckNum + " finished the race!");
						}
						calcPositions(raceID);
						//if (competitor.isThePlayer)
						//{
							this.finishCurrentRace(competitor);
						//}
					}
					else
					{
						game.log("ERROR: unhandled race event: checkpointNum "+checkpointNum+", finishNum "+this.raceDict[raceID].finishNum);
						//this.message("Unhandled finish line event: " + competitor.truckNum, "flag_green.png");
					}
				}
				else if( checkpointNum == this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint) )
				{ // passing a normal checkpoint
					competitor.lastCheckpointInstance = inst;
					competitor.penaltyGiven = false;
					if (competitor.isThePlayer)
						game.log("You reached checkpoint: " + checkpointNum + " / " + this.raceDict[raceID].checkPointsCount + ".");
					else
						game.log("Number " + competitor.truckNum + " reached checkpoint: " + checkpointNum + " / " + this.raceDict[raceID].checkPointsCount + ".");
					this.advanceCheckpoint(raceID, eventTruckNum, competitor);
				}
				else{
					if( (checkpointNum == 0) and this.restartRaceOnStart )
					{
						if (canEndActiveRace(not (competitor.isThePlayer)))
						{
							game.log("Checkpoint 0 reached. (Re)starting the race.");
							this.cancelCurrentRace();
							competitor.lastCheckpointInstance = inst;
							competitor.penaltyGiven = false;
							this.startRace(raceID, competitor);
						}
					}
					else if(competitor.isThePlayer and checkpointNum == this.raceDict[raceID].getNextCheckpointNum(this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint)) )
					{
						this.message("You missed a checkpoint! Please go back and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(this.lastCheckpoint)+" first.", "cross.png");
						game.log("You missed a checkpoint! Please go back and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(this.lastCheckpoint)+" first.");
					}
					else if(competitor.isThePlayer and checkpointNum == this.raceDict[raceID].getPreviousCheckpointNum(competitor.lastCheckpoint) )
					{
						this.message("Wrong checkpoint! Are you driving in the correct direction?", "cross.png");
						game.log("Wrong checkpoint! Are you driving in the correct direction?");
					}
					else if (competitor.isThePlayer)
					{
						this.message("Wrong checkpoint! You must find and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint), "cross.png");
						game.log("Wrong checkpoint! You must find and pass checkpoint "+this.raceDict[raceID].getNextCheckpointNum(competitor.lastCheckpoint));
					}
				}
			}
			else
			{
				if(checkpointNum == 0 and not this.obligatedFinish and not this.raceDict[raceID].isLocked() )
				{
					// we passed the startline of another race
					if (canEndActiveRace(not (competitor.isThePlayer)))
					{
						this.cancelCurrentRace();
						competitor.lastCheckpointInstance = inst;
						competitor.penaltyGiven = false;
						if (competitor.isThePlayer)
						{
							this.startRace(raceID, competitor);
						}
					}
				}
			}
		}
	}

	string formatTime(double seconds)
	{
		if( seconds > 60.0 )
			return floor(seconds/60.0)+" minutes and "+(seconds%60.0)+" seconds";
		else
			return seconds+" seconds";
	}

	//  pre: The race corresponding with the raceID exists
	//       There's no other race running
	// post: The race is running
	void startRace(int raceID, racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::startRace(" + raceID + ") called.");
		if (competitor !is null)
		{
			// debug: game.log("racesManager::startRace(" + raceID + ") called for truck: " + competitor.truckNum + ".");
		}

		// if the race is locked, then we do nothing
		if( this.raceDict[raceID].isLocked() )
		{
			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("LockedRace", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "LockedRace");
				args.set("raceID", raceID);
				handle(args);
			}
			return;
		}
/*
		RaceClass@ champRace;
		if (championshipManager.hasCurrentRace())
		{
			@champRace = @championshipManager.getCurrentRace();
			if (champRace.GetID() != raceID)
			{
				//TODO Fix raceID @champRace = null;
				this.message("Got champRace but wrong race ID!", "bullet_go.png");
				game.log("Got champRace but wrong race ID! raceID: " + raceID + " champRace.GetID(): " + champRace.GetID() + ".");
			}
			if (champRace !is null)
			{
				//THIS WORKS
				this.message("Got champRace and its not null!", "bullet_go.png");
			}
			else
			{
				this.message("Got champRace but it's NULL!", "bullet_go.png");
			}
		}
		else
		{
			this.message("championshipManager has NO CURRENT RACE!", "bullet_go.png");
		}
*/						
		competitor.state = STATE_Racing;
		this.currentRace = raceID;
		competitor.currentRace = raceID;
		competitor.currentLap = 1;
		competitor.lastCheckpoint = 0;
		competitor.lastLapTime = 0.0;
		competitor.lastRaceTime = 0.0;
/*
		if (champRace !is null && champRace.IsRunning())
		{
			//If it's a standing start, set going by the ChampionshipManager
			//then timing for all vehicles starts from that moment NOT when the line is first crossed.
			double champRaceStartTime = game.getRaceStartTime(raceID);//champRace.GetRaceStartTime();
			double frameRate = game.getFPS();
			game.log("champRaceStartTime = " + champRaceStartTime);
			if (champRaceStartTime > 0)
			{
				game.log("champRaceStartTime > 0!");
			}
			if (frameRate > 0)
			{
				game.log("frameRate is:  " + frameRate);
			}
			if (champRaceStartTime > 0)
			{
				double dChampRaceStartTime = double(champRaceStartTime);
				game.log("double(champRaceStartTime): " + dChampRaceStartTime);
				competitor.raceStartTime = double(champRace.GetRaceStartTime());
//				this.message("race start time set from champRace to " + competitor.raceStartTime + " for raceID " + raceID + ".", "bullet_go.png");
				game.log("race start time set from champRace to " + competitor.raceStartTime + " for raceID " + raceID + ".");
			}
			//See if the number of laps for this race is configured by the ChampionshipManager
			int champLaps = champRace.GetNumberOfLaps();
			if (champLaps > 0)
			{
				//this.LAPS_NoLaps = champLaps;
				this.raceDict[raceID].laps = champLaps;
				game.log("race number of laps set from champRace to " + champLaps + " for raceID " + raceID + ".");
			}
			else
			{
				game.log("Could not get number of laps from champRace: " + champLaps + ".");
			}
		}
		else
*/
		{
			competitor.currentLap = 1;
			competitor.lastCheckpoint = 0;
			//Angelscript only way of starting a race, just starting the timer as the first car crosses the line.
			if (this.raceStartTime > 0.0)
			{
				competitor.raceStartTime = this.raceStartTime;
//				this.message("race start time initialized from angelscript race object to " + competitor.raceStartTime, "bullet_go.png");
				game.log("race start time initialized from angelscript race object to " + competitor.raceStartTime + ".");
			}
			else
			{
				competitor.raceStartTime = game.getTime();
				//this.message("race start time initialized from timer to " + competitor.raceStartTime + ".", "bullet_go.png");
				game.log("race start time initialized from timer to " + competitor.raceStartTime + ".");
			}
		}
		if (this.raceStartTime <= 0.0)
		{
			this.raceStartTime = competitor.raceStartTime;
		}
		competitor.lapStartTime = this.raceStartTime;
		game.setTimer(competitor.truckNum, float(competitor.raceStartTime), true); //game.startTimer(competitor.truckNum);
		this.recalcArrow(competitor);
		if (competitor.isThePlayer)
		{
			this.truckNum = competitor.truckNum;//game.getCurrentTruckNumber();
			// Set race start time globally so it shows in the HUD
			game.setTimer(-1, float(competitor.raceStartTime), true);
		}
		raceBuilder @theRace = @this.raceDict[raceID];
		//NOTE These two lines cause an assertion to fail in CompileStatementBlock() when we're using raceDictionary:
		//this.raceDict[raceID].lastTimeTillPoint[0] = 0.0;
		//(this.raceDict[raceID].lastTimeTillPoint)[0] = 0.0;
		theRace.lastTimeTillPoint[0] = 0.0;
		competitor.penaltyTime.resize(0);
		competitor.penaltyTime.resize(this.raceDict[raceID].checkPointsCount);
		if (theRace.entrants.find(competitor.truckNum) < 0)
			theRace.entrants.insertLast(competitor.truckNum);

		if (competitor.isThePlayer)
		{
			// build the message
			this.message("Race "+this.raceDict[raceID].raceName+" started!", "bullet_go.png");
			if( (this.raceDict[raceID].laps > 1) )
				this.message("     Laps: "+this.raceDict[raceID].laps, "arrow_rotate_clockwise.png");
			if( this.showBestRace and this.raceDict[raceID].bestRaceTime > 0.0 )
				this.message("     Best race time: "+this.formatTime(this.raceDict[raceID].bestRaceTime)+"!", "information.png");
			if( this.showBestLap and this.raceDict[raceID].bestLapTime > 0.0 and this.raceDict[raceID].laps != this.LAPS_NoLaps and this.raceDict[raceID].laps != this.LAPS_One)
				this.message("     Best lap time: "+this.formatTime(this.raceDict[raceID].bestLapTime)+"!", "information.png");
			this.message("     Good Luck!", "emoticon_smile.png");
		}
		else
			this.message("Number " + competitor.truckNum + " started race "+this.raceDict[raceID].raceName+"!", "bullet_go.png");
		
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceStart", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceStart");
			args.set("raceID", raceID);
			handle(args);
		}
	}

	// this is private as this should only be called when the user drives through the finish checkpoint
	// If you need to abort a race, use racesManager::cancelCurrentRace() instead.
	void finishCurrentRace(racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::finishCurrentRace() called.");

		int rid = competitor.currentRace;

		// get the lap time
		double lapTime = game.getTime() - competitor.lapStartTime;
		// get the race time
		double raceTime = game.getTime() - competitor.raceStartTime;
		
		competitor.lastLapTime = lapTime;
		competitor.lastRaceTime = raceTime;

		// calculate race time difference
		string raceTimeDiff = "";
		double bestRaceTime = this.raceDict[rid].bestRaceTime;
		if(this.showTimeDiff and bestRaceTime > 0.0)
		{
			if( (raceTime-bestRaceTime) > 0 )
				raceTimeDiff = " (+"+ (raceTime-bestRaceTime) +")";
			else if( (raceTime-bestRaceTime) < 0 )
				raceTimeDiff = " ("+ (raceTime-bestRaceTime) +")";
		}

		// calculate lap time difference
		string lapTimeDiff = "";
		double bestLapTime = this.raceDict[rid].bestLapTime;
		if(this.showTimeDiff and bestLapTime > 0.0)
		{
			if( (lapTime-bestLapTime) > 0 )
				lapTimeDiff = " (+"+ (lapTime-bestLapTime) +")";
			else if( (lapTime-bestLapTime) < 0 )
				lapTimeDiff = " ("+ (lapTime-bestLapTime) +")";
		}

		// do more time stuff
		raceBuilder @theRace = @this.raceDict[rid];
		if (competitor.isThePlayer)
			theRace.lastTimeTillPoint[theRace.checkPointsCount-1] = lapTime;
		bool newBestRace;
		if (competitor.isThePlayer)
			this.addRaceTime(rid, raceTime, newBestRace);
		bool newBestLap = false;
		bool newPersonalBestLap = false;
		this.addLapTime(rid, lapTime, competitor, newBestLap, newPersonalBestLap);

		//debug: game.log("finishRaceCurrentRace() for Number " + competitor.truckNum + " Calling stopTimer()");
		game.stopTimer(competitor.truckNum);

		// calculate final position
 		this.calcPositions(rid);

		// reset some values
		competitor.lastCheckpoint = -1;
		competitor.lastRace = competitor.currentRace;
		competitor.currentRace = -1;
		competitor.currentLap = -1;
		competitor.state = this.STATE_Finished;
		if (competitor.isThePlayer)
		{
			this.removeArrow();
		}
		//competitor.lastRaceEventInstance = ""; //Currently this causes the race to instantaneously restart! WHY?
		
		if (competitor.isThePlayer)
		{
			int numEntrants = this.raceDict[rid].entrants.length();

			// race completed!
			this.raceDict[rid].completed = true;

			if (numEntrants > 1)
			{
				// build the message
				if (competitor.racePosition == 1)
				{
					//TODO can we make a chequered flag for these messages?
					this.message("CONGRATULATIONS! You won the race! Time: "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
				}
				else if (competitor.racePosition == 2)
				{
					this.message("Well done! You finished 2nd. Time: "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
				}
				else if (competitor.racePosition == 3)
				{
					this.message("Well done! You finished 3rd. Time: "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
				}
				else
				{
					this.message("Finished! Position: "+competitor.racePosition+" Time: "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
				}
				if( this.showBestRace and newBestRace )
					this.message("New best race time!", "flag_green.png");
				if( this.showBestLap and newBestLap  and this.raceDict[rid].laps != this.LAPS_NoLaps and this.raceDict[rid].laps != this.LAPS_One)
					this.message("New best lap time!"+lapTimeDiff, "flag_green.png");
			}
			else
			{
				// build the message
				this.message("Finished! You needed "+this.formatTime(raceTime)+"!"+raceTimeDiff, "flag_green.png");
				if( this.showBestRace and newBestRace )
					this.message("     New best race time!", "flag_green.png");
				if( this.showBestLap and newBestLap  and this.raceDict[rid].laps != this.LAPS_NoLaps and this.raceDict[rid].laps != this.LAPS_One)
					this.message("     New best lap time!"+lapTimeDiff, "flag_green.png");
			}

			// store the new race times
			saveRace(rid);

			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("RaceFinish", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "RaceFinish");
				args.set("raceID", rid);
				args.set("newBestLap", newBestLap);
				args.set("newBestRace", newBestRace);
				handle(args);
			}
		}
	}

	// This is private, as you shouldn't manually advance a lap
	void advanceLap(racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::advanceLap() called.");

		int rid = competitor.currentRace;

		// get the lapTime
		double lapTime = game.getTime() - competitor.lapStartTime;

		// calculate time difference
		string timeDiff = "";
		if(this.showTimeDiff and competitor.isThePlayer and this.raceDict[rid].bestLapTime > 0.0)
		{
			if( (lapTime-this.raceDict[rid].bestLapTime) > 0 )
				timeDiff = " (+"+ (lapTime-this.raceDict[rid].bestLapTime) +")";
			else if( (lapTime-this.raceDict[rid].bestLapTime) < 0 )
				timeDiff = " ("+ (lapTime-this.raceDict[rid].bestLapTime) +")";
		}

		// do time stuff
		raceBuilder @theRace = @this.raceDict[rid];
		if (competitor.isThePlayer)
			theRace.lastTimeTillPoint[theRace.checkPointsCount-1] = lapTime;
		double time = game.getTime() - competitor.lastCheckpointTime;
		competitor.lastCheckpointTime = time;
		bool newBestLap = false;
		bool newPersonalBestLap = false;
		this.addLapTime(rid, lapTime, competitor, newBestLap, newPersonalBestLap);

		//game.log("advanceLap() for truckNum " + competitor.truckNum + " Calling stopTimer()");
		game.stopTimer(competitor.truckNum);
		game.startTimer(competitor.truckNum);

		competitor.lapStartTime = game.getTime();

		// advance the lap
		competitor.currentLap = competitor.currentLap + 1;
		competitor.lastCheckpoint = 0;
		competitor.lastLapTime = lapTime;
		calcPositions(rid);
		//competitor.lastCheckpointTime = 0.0;

		//game.log("advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint);

		this.recalcArrow(competitor);
		
		//this.message("advanceLap() truckNum: " + competitor.truckNum + " lastCheckpoint: " + competitor.lastCheckpoint, "flag_green.png");

		// build the message
		if(competitor.isThePlayer and this.raceDict[rid].laps != this.LAPS_Unlimited )
			this.message("Lap "+(competitor.currentLap-1)+" done!", "flag_green.png");
		if(competitor.isThePlayer and this.showBestLap and newBestLap )
			this.message("     New best lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		else if (competitor.isThePlayer)
			this.message("     Lap time: "+this.formatTime(lapTime)+"!"+timeDiff, "flag_green.png");
		
		// store the new race times
		if (competitor.isThePlayer)
			saveRace(rid);
		
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("AdvanceLap", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "AdvanceLap");
			args.set("raceID", rid);
			handle(args);
		}
	}

	// called by raceEvent when the user drives through a checkpoint that is not a finishline and not a startline
	//  pre: The race corresponding with the raceID exists
	//       The race corresponding with the raceID is running at the moment
	// post: We have advanced 1 checkpoint
	void advanceCheckpoint(int raceID, int eventTruckNum, racesCompetitor@ competitor)
	{
		// debug: game.log("racesManager::advanceCheckpoint(" + raceID + ") called.");
		raceBuilder @theRace = @this.raceDict[raceID];
		competitor.lastCheckpoint = theRace.getNextCheckpointNum(competitor.lastCheckpoint);
		this.arrowMethod == this.ARROW_AUTO;//this.arrowMethod = competitor.lastCheckpoint;

		//this.message("recalc arrow checkpoint to " + this.arrowMethod + " for eventTruckNum: "+eventTruckNum+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");

		this.recalcArrow(competitor);

		double time = game.getTime() - competitor.lapStartTime;
		competitor.lastCheckpointTime = time;
		calcPositions(raceID);
		//TODO ! The player's car (or currently viewed car) may have changed positions here, in which case the race overlay (direction arrow)
		//would need to be updated here even though competitor is not that car!

		// calculate time difference
		string timeDiff = "";
		//TODO at the moment these best times are across all competitors only
		if(this.showTimeDiff and theRace.bestTimeTillPoint[competitor.lastCheckpoint] > 0.0)
		{
			double diff = time-theRace.bestTimeTillPoint[competitor.lastCheckpoint];
			if (diff > 0)
				timeDiff = " (+"+ (diff) +")";
			else if (diff < 0)
			{
				timeDiff = " ("+ (diff) +")";
				theRace.bestTimeTillPoint[competitor.lastCheckpoint] = time;
			}
			game.setTimeDiff(diff);
		}
		else
			theRace.bestTimeTillPoint[competitor.lastCheckpoint] = time;

		if (competitor.isThePlayer)
			theRace.lastTimeTillPoint[competitor.lastCheckpoint] = time;

		if (competitor.isThePlayer)
		{
				// build the message
	//		if( theRace.laps == this.LAPS_NoLaps )
	//			this.message("Passed checkpoint "+competitor.lastCheckpoint+" of "+(theRace.checkPointsCount-1)+" after "+this.formatTime(time)+"."+timeDiff, "flag_orange.png");
	//		else
	//			this.message("Passed checkpoint "+competitor.lastCheckpoint+" of "+(theRace.checkPointsCount)+" after "+this.formatTime(time)+"."+timeDiff, "flag_orange.png");
			if( competitor.currentLap >= theRace.laps and theRace.finishNum == theRace.getNextCheckpointNum(competitor.lastCheckpoint) )
				this.message("Go for the finish!", "flag_orange.png");
			else
			{
				if (theRace.laps > 0)
				{
	//				this.message("Lap "+ competitor.currentLap +" of " + theRace.laps + ". event " + eventTruckNum + " Passed chkpnt " + competitor.lastCheckpoint+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
				}
				else
				{
	//				this.message("Lap "+ competitor.currentLap +".", "flag_orange.png");
				}
			}
		}


		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("Checkpoint", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "Checkpoint");
			args.set("raceID", raceID);
			handle(args);
		}
	}

	bool calcPosition(racesCompetitor@ competitor)
	{
		if (competitor.state == this.STATE_NotInRace)
		{
			competitor.racePosition = 0;
			return false;
		}
		if (competitor.state == this.STATE_Finished)//((competitor.state == this.STATE_Finished) and (competitor.racePosition > 0))
		{
			//Nothing to do. They already have their final race position.
			return false;
		}
		string debugTxt = "1. Truck " + competitor.truckNum + " is:\n";
		int position = 1;
		int compRace = competitor.currentRace;
		if (competitor.state == this.STATE_Finished)
		{
			compRace = competitor.lastRace;
		}
		//array<string>@ keys = this.competitors.getKeys();
		//for (int i = 0; i < keys.length(); i++)
		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			
			if (!this.competitors.get(formatInt(i, ''), @c) || (c is null))
			{
				continue;
			}
			
			int cRace = c.currentRace;
			if (c.state == this.STATE_Finished)
			{
				cRace = c.lastRace;
			}
			else if (competitor.state == this.STATE_Finished)
			{
				//If competitor has finished the race and c hasn't, then c is not ahead, so ignore
				continue;
			}
			
			if (c.truckNum != competitor.truckNum && compRace == cRace)
			{
				if (c.lastRaceTime > 0 && (competitor.lastRaceTime == 0 || c.lastRaceTime < competitor.lastRaceTime))
				{
					//If c has finished the race, just compare total race time to competitor's
					position++;
					debugTxt += "" + position + ". behind truck " + c.truckNum + " which finished the race in " + c.lastRaceTime + ",\n";
				}
				else if (c.currentLap > competitor.currentLap)
				{
					position++;
					debugTxt += "" + position + ". behind truck " + c.truckNum + " which is on lap " + c.currentLap + ",\n";
				}
				else if (c.currentLap == competitor.currentLap)
				{
					if (c.lastCheckpoint > competitor.lastCheckpoint)
					{
						position++;
						debugTxt += "" + position + ". behind truck " + c.truckNum + " that passed chkpnt " + c.lastCheckpoint + ",\n";
					}
					else if (c.lastCheckpoint == competitor.lastCheckpoint)
					{
						//We need to compare the timings to get position at last checkpoint, or TODO better compare their on track positions to get instantaneous position
						//if (c.lastCheckpointTime < competitor.lastCheckpointTime)
						//{
						//	position++;
						//}
						//else
						{
							raceBuilder @theRace = @this.raceDict[compRace];
							int nextChp = theRace.getNextCheckpointNum(competitor.lastCheckpoint);
							double[] v = theRace.checkpoints[nextChp][0];//TODO Don't understand this - it crashes! Works without it and 2nd 3 digits are rotations: this.raceList[competitor.currentRace].chpInstances[nextChp]];
							vector3 va = vector3(v[0], v[1], v[2]);
							//this.message("next chp coords length " + v.length(), "flag_orange.png");
							BeamClass @compbeam = game.getTruckByNum(competitor.truckNum);
							BeamClass @cbeam = game.getTruckByNum(c.truckNum);
							if (compbeam == null or cbeam == null)
								return false;
							vector3 comppos = vector3(compbeam.getVehiclePosition());
							vector3 cpos = vector3(cbeam.getVehiclePosition());
							float compdist = ((va.x-comppos.x)*(va.x-comppos.x))+((va.y-comppos.y)*(va.y-comppos.y))+((va.z-comppos.z)*(va.z-comppos.z));// va.squaredDistance(comppos) is always zero WHY?!
							float cdist = ((va.x-cpos.x)*(va.x-cpos.x))+((va.y-cpos.y)*(va.y-cpos.y))+((va.z-cpos.z)*(va.z-cpos.z));// both these give zero too! WHY? pow(va.x-cpos.x,2.0)+pow(va.y-cpos.y,2.0)+pow(va.z-cpos.z,2.0);// va.squaredDistance(cpos);
							if (cdist < compdist)
							{
								position++;
								debugTxt += "" + position + ". behind truck " + c.truckNum + " (cdist=" + cdist + " compdist=" + compdist + " nextChp=" + nextChp + "),\n";
							}
							else
							{
								debugTxt += "" + position + ". in front of truck " + c.truckNum + " (cdist=" + cdist + " compdist=" + compdist + " nextChp=" + nextChp + "),\n";
								debugTxt += " nextChp is (" + v[0] + "," + v[1] + "," + v[2] + ") cpos is (" + cpos.x + "," + cpos.y + "," + cpos.z + ")\n";
								debugTxt += " comppos is (" + comppos.x + "," + comppos.y + "," + comppos.z + ") chkpnt is (" + va.x + "," + va.y + "," + va.z + ")\n";
							}
							
						}
					}
				}
			}
		}
		bool positionChanged = competitor.racePosition != position;
		competitor.racePosition = position;
		if (positionChanged)// and competitor.isThePlayer)
		{
//			this.message(debugTxt, "flag_orange.png");
		}
		return positionChanged;
	}

	void calcPositions(int raceID)
	{
		int numEntrants = this.raceDict[raceID].entrants.length();
		//array<string>@ keys = this.competitors.getKeys();
		//for (int i = 0; i < keys.length(); i++)
		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			if (this.competitors.get(formatInt(i, ''), @c) && !(c is null) && (c.currentRace == raceID || (c.state == this.STATE_Finished && c.lastRace == raceID)))
			{
				//This will be a bit slow - we ideally need to sort all the competitors into position in one go instead of calculating one by one
				bool positionChanged = calcPosition(c);
				if (positionChanged && c.isThePlayer) // or i == currentTruckNum
				{
					int cRace = c.currentRace;
					if (c.state == this.STATE_Finished)
					{
						cRace = c.lastRace;
					}
					raceBuilder @theRace = @this.raceDict[cRace];
					int nextChp = theRace.getNextCheckpointNum(c.lastCheckpoint);
					double[] v = theRace.checkpoints[nextChp][0];
					string racePosText;
					string lapText;
					
					if (c.racePosition > 0)
					{
						racePosText = "\nposition " + c.racePosition + " / " + numEntrants;
					}
					else
					{
						racePosText = "\n ";
					}
					
					int lap = 1;
					if (c.currentLap > 0)
					{
						lap = c.currentLap;
					}
					
					if (theRace.laps == LAPS_Unlimited)
					{
						lapText = "\nlap " + lap + " / -";
					}
					else if (theRace.laps > 0)
					{
						lapText = "\nlap " + lap + " / " + theRace.laps;
					}
					else
					{
						lapText = "\nlap " + lap + " / 1";
					}
					
					game.updateDirectionArrow(theRace.raceName+"\ncheckpoint "+nextChp+" / "+(theRace.checkPointsCount+"\n"+lapText+racePosText), vector3(v[0], v[1], v[2]));
				}
			}
		}
	}

	
	void setBestLapTime(int raceID, double time)
	{
		this.raceDict[raceID].bestLapTime = time;
	}
	void setBestRaceTime(int raceID, double time)
	{
		this.raceDict[raceID].bestRaceTime = time;
	}

	// Set a new best laptime (if it's better than the old best laptime)
	//  pre: The race corresponding with the raceID exists
	// post: The new time is checked and stored if necessary
	void addLapTime(int raceID, double time, racesCompetitor@ competitor, bool &out newBestLap, bool &out newPersonalBestLap)
	{
		//debug: game.log("addLapTime()");
		raceBuilder @theRace = @this.raceDict[raceID];
		if( time > 0.0 and (theRace.bestLapTime > time or theRace.bestLapTime == 0.0))
		{
			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("NewBestLap", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "NewBestLap");
				args.set("raceID", raceID);
				args.set("oldTime", this.raceDict[raceID].bestLapTime);
				args.set("newTime", time);
				handle(args);
			}

			theRace.bestLapTime = time;
			game.setBestLapTime(time);
			newBestLap = true;
		}
		else
			newBestLap = false;

		//check for personal best also, now that bots are also setting times
		if (time > 0.0 and (competitor.bestLapTime > time or competitor.bestLapTime == 0.0))
		{
			competitor.bestLapTime = time;
			newPersonalBestLap = true;
		}
		else
			newPersonalBestLap = false;

		if( this.submitScore and competitor.isThePlayer)
		{				
			string api_return;
			dictionary dict;
			dict.set("raceManagerVersion", ""+this.raceManagerVersion);
			dict.set("raceName", ""+theRace.raceName);
			dict.set("raceVersion", ""+theRace.raceVersion);
			dict.set("laptime", time);
			string times = "0.0";
			for( uint i = 1; i < theRace.lastTimeTillPoint.length() ; i++ )
			{
			times += ";"+theRace.lastTimeTillPoint[i];
			// dict.set("chptime"+i, this.raceList[raceID].lastTimeTillPoint[i]);
			}
			dict.set("chptimes", ""+times);
			
			times = ""+competitor.penaltyTime[0];
			for( uint i = 1; i < competitor.penaltyTime.length() ; i++ )
			{
			times += ";"+competitor.penaltyTime[i];
			}
			dict.set("penaltytimes", ""+times);
			
			//debug: game.log("About to submit score.");
			int res = game.useOnlineAPI("/submit_race_time/", dict, api_return);
			// debug: game.log("useOnlineAPI returned: " + res);
			// debug: game.log("useOnlineAPI return string: " + api_return);
		}
	}

	// Set a new best racetime (if it's better than the old best racetime)
	//  pre: The race corresponding with the raceID exists
	// post: The new time is checked and stored if necessary
	void addRaceTime(int raceID, double time, bool &out newBestRace)
	{
		if (time > 0 and (this.raceDict[raceID].bestRaceTime > time or this.raceDict[raceID].bestRaceTime == 0.0))
		{
			// call the callback function
			RACE_EVENT_CALLBACK @handle;
			if( callbacks.get("NewBestRace", @handle) and not (handle is null))
			{
				dictionary args;
				args.set("event", "NewBestRace");
				args.set("raceID", raceID);
				args.set("oldTime", this.raceDict[raceID].bestRaceTime);
				args.set("newTime", time);
				handle(args);
			}

			this.raceDict[raceID].bestRaceTime = time;

			newBestRace = true;
		}
		else
			newBestRace = false;
	}

	void eventCallback(int eventnum, int value)
	{
		// debug: game.log("raceManager::eventCallback("+eventnum+", "+value+") called");

		//Ideally this needs a truckNum. For now, we'll just do this:
		racesCompetitor@ competitor;
		if (!competitors.get(formatInt(this.truckNum, ''), @competitor) or competitor is null)
		{
			return;
		}
		
		if( competitor.state != this.STATE_Racing )
			return;

		// this never gets called
		if( eventnum == SE_TRUCK_EXIT )
		{
			if( this.abortOnVehicleExit )
			{
				this.cancelCurrentRace();
				this.message("Race aborted.", "stop.png");
			}
			else if( !this.silentMode )
				this.message("Get back in the vehicle!", "stop.png");
		}
		else if( eventnum == SE_TRUCK_ENTER and this.truckNum != value and !this.allowVehicleChanging)
		{
			this.cancelCurrentRace();
			this.message("You cannot switch vehicles during a race! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_TRUCK_RESET and this.truckNum == value)
		{
			this.cancelCurrentRace();
			this.message("You must not reset the vehicle during a race! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_TRUCK_TELEPORT and this.truckNum == value)
		{
			this.cancelCurrentRace();
			this.message("You must not teleport the vehicle during a race! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_GENERIC_DELETED_TRUCK and this.truckNum == value and !this.allowVehicleChanging)
		{
			this.cancelCurrentRace();
			this.message("You must finish the race with the vehicle you started it! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_TRUCK_MOUSE_GRAB and this.truckNum == value )
		{
			this.cancelCurrentRace();
			this.message("You must not grab the vehicle during a race! Race aborted.", "stop.png");
		}
		else if( eventnum == SE_ANGELSCRIPT_MANIPULATIONS )
		{
			this.cancelCurrentRace();
			this.message("AngelScript injection is not allowed during races! Race aborted.", "stop.png");
		}
	}

	void message(const string &in msg, const string &in icon)
	{
		if(!this.silentMode)
			game.message(msg, icon, 10000, true); // 10 seconds visible, enforce visibility
	}

	void unlockRace(int raceID)
	{
		this.raceDict[raceID].locked = false;
	}

	void lockRace(int raceID)
	{
		this.raceDict[raceID].locked = true;
	}

	void deleteRace(int raceID)
	{
		// debug: game.log("raceManager::deleteRace("+raceID+") called.");
		if( this.currentRace == raceID )
			this.cancelCurrentRace();
		this.raceDict[raceID].destroy();
		this.raceDict[raceID].awaitingRecycling = true;

		if( raceID == this.raceCount-1 )
		{
			this.raceCount--;
			this.raceDict.resize(this.raceCount);
		}
	}

	int getRaceIDbyName(const string &in raceName_in)
	{
		for( int i = 0; i<this.raceCount; i++ )
		{
			if( not (this.raceDict[i] is null) and (raceName_in == this.raceDict[i].raceName) )
				return i;
		}
		return -1;
	}

	void cancelCurrentRace()
	{
		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( callbacks.get("RaceCancel", @handle) and not (handle is null))
		{
			dictionary args;
			args.set("event", "RaceCancel");
			args.set("raceID", this.currentRace);
			handle(args);
		}

		for (int i = this.minTruckNum; i <= this.maxTruckNum; i++)
		{
			racesCompetitor@ c = null;
			if (this.competitors.get(formatInt(i, ''), @c) and !(c is null) and (c.currentRace >= 0 or c.state != this.STATE_NotInRace))
			{
				this.cancelCurrentRace(c);
			}
		}

		if (this.currentRace >= 0)
		{
			raceBuilder @theRace = @this.raceDict[this.currentRace];
			theRace.entrants.resize(0);
		}
		this.lastCheckpoint = -1;
		this.currentRace = -1;
		this.currentLap = -1;
		this.raceStartTime = 0;
		//this.lastRaceEventInstance = "";
		this.state = this.STATE_NotInRace;
		game.stopTimer(-1);
		this.removeArrow();
	}

	void cancelCurrentRace(racesCompetitor @competitor)
	{		
		competitor.lastCheckpoint = -1;
		if (competitor.currentRace >= 0)
			competitor.lastRace = competitor.currentRace;
		competitor.currentRace = -1;
		competitor.currentLap = -1;
		competitor.raceStartTime = 0;
		competitor.state = this.STATE_NotInRace;
		game.stopTimer(competitor.truckNum);
	}
	
	bool raceCompleted(int raceID)
	{
		return this.raceDict[raceID].completed;
	}

	int getCurrentRaceID()
	{
		return this.currentRace;
	}

	double getBestLapTime(int raceID)
	{
		return this.raceDict[raceID].bestLapTime;
	}

	double getBestRaceTime(int raceID)
	{
		return this.raceDict[raceID].bestRaceTime;
	}

	bool addPenaltySeconds(racesCompetitor@ competitor, int seconds)
	{
		if( competitor.state == this.STATE_NotInRace )
			return false;
		competitor.raceStartTime -= seconds;
		competitor.lapStartTime  -= seconds;
		competitor.penaltyTime[this.lastCheckpoint] += seconds;
		return true;
	}

	void setLaps(int raceID, int laps)
	{
		this.raceDict[raceID].laps = laps;
	}

	void setRaceName(int raceID, const string &in raceName)
	{
		this.raceDict[raceID].raceName = raceName;
	}

	int getLaps(int raceID)
	{
		return this.raceDict[raceID].laps;
	}

	raceBuilder@ getRace(int raceID)
	{
		return @this.raceDict[raceID];
	}

	// this allows you to have duplicate checkpoints (useful to create shortcuts or splitted tracks)
	void addCheckpoint(int raceID, int number, const string &in objName, double[] coords)
	{
		this.raceDict[raceID].addCheckpoint(number, objName, coords);
	}

	void addCheckpointList(int raceID, uint startNumber, const string &in objName, double[][] coords)
	{
		this.raceDict[raceID].addChpCoordinates(coords, objName, objName, objName, startNumber);
	}

	// Advanced users only!
	// this deletes a checkpoint
	// Warning: if you delete a checkpoint in the middle of your race, then it will be impossible
	//          to finish the race, as it will be impossible to pass that checkpoint.
	// Also don't use this on running races (unless you know what you're doing)
	void deleteCheckPoint(int raceID, int number, int instance)
	{
		this.raceDict[raceID].deleteCheckpoint(number, instance);
	}

	// if the user comes in this event box, the current race will be cancelled
	// example usage: if the users drives off the track
	// (race will be stopped)
	void addCancelPoint(int raceID, const string &in objName, const vector3 &in pos, const vector3 &in rot, RACE_EVENT_CALLBACK @callback)
	{
		dictionary dict;
		dict.set("raceID", raceID);
		dict.set("oname", ""+objName);
		// dict.set("position", vector3(pos));
		// dict.set("rotation", vector3(rot));
		dict.set("callback", @callback);
		this.callbacks.set("race_cancel_"+cancelPointCount, dict);
		game.spawnObject(objName, "race_cancel_"+cancelPointCount, pos, rot, "raceCancelPointHandler", false);
	}
	void addCancelPoint(int raceID, const string &in objName, const double[] &in v, RACE_EVENT_CALLBACK @callback)
	{
		addCancelPoint(raceID, objName, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]), @callback);
	}
	void addCancelPoint(int raceID, const string &in objName, const vector3 &in pos, const vector3 &in rot)
	{
		dictionary dict;
		dict.set("raceID", raceID);
		dict.set("oname", ""+objName);
		// dict.set("position", vector3(pos));
		// dict.set("rotation", vector3(rot));
		dict.set("callback", null);
		this.callbacks.set("race_cancel_"+cancelPointCount, dict);
		game.spawnObject(objName, "race_cancel_"+cancelPointCount, pos, rot, "raceCancelPointHandler", false);
	}
	void addCancelPoint(int raceID, const string &in objName, const double[] &in v)
	{
		addCancelPoint(raceID, objName, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]));
	}

	void raceCancelPointHandler(int trigger_type, const string &in inst, const string &in box, int nodeid)
	{
		if( this.state == this.STATE_NotInRace )
			return;

		dictionary dict;
		if( not this.callbacks.get(inst, dict) )
			return;

		int raceID;
		dict.get("raceID", raceID);
		if( raceID != -1 and this.currentRace != raceID )
			return;

		this.cancelCurrentRace();

		// call the callback function
		RACE_EVENT_CALLBACK @handle;
		if( dict.get("callback", @handle) and not (handle is null) )
		{
			dictionary args;
			args.set("event", "cancel_point");
			args.set("raceID", this.currentRace);
			args.set("inst", ""+inst);
			args.set("trigger_type", trigger_type);
			args.set("box", ""+box);
			args.set("nodeid", nodeid);
			handle(args);
		}
	}

	void recalcArrow(racesCompetitor@ competitor)
	{
		//We don't want to start hiding the arrow if an AI competitor passed a checkpoint. Just do nothing.
		if (!competitor.isThePlayer)
		{
			return;
		}
		if( competitor.state == this.STATE_Racing)
			this.setupArrow(this.raceDict[competitor.currentRace].getNextCheckpointNum(competitor.lastCheckpoint), competitor);
		else
			this.removeArrow();
	}

	// set a navigational arrow
	void setupArrow(int position, racesCompetitor@ competitor)
	{
		raceBuilder @theRace = @this.raceDict[competitor.currentRace];
		if( (position < 0) or (position > theRace.checkPointsCount-1) )
		{ // hide the arrow
			this.removeArrow();
			return;
		}

		double[] v;
		int instanceNum = this.arrowMethod;
		if( this.arrowMethod == this.ARROW_AUTO )
		{
			array<string>@ tmp = competitor.lastCheckpointInstance.split("|");
			// int checkpointNum = parseInt(tmp[2]);
			int raceID        = parseInt(tmp[1]);
			if( raceID == competitor.currentRace )
				instanceNum = parseInt(tmp[3]);
		}

		if( theRace.checkpoints[position].length() > uint(instanceNum) )
			v = theRace.checkpoints[position][instanceNum];
		else if( theRace.checkpoints[position].length() > 0 )
			v = theRace.checkpoints[position][0];
		else
		{
			//debug: this.message("removing arrow this.currentRace: " + this.currentRace + " position: "+position+" curTruckNum: "+game.getCurrentTruckNumber(), "flag_orange.png");
			this.removeArrow();
			return;
		}

		string racePosText;
		string lapText;
		int numEntrants = theRace.entrants.length();
		if (competitor.racePosition > 0 and numEntrants > 1)
		{
			racePosText = "\nposition " + competitor.racePosition + " / " + numEntrants;
		}
		else
		{
			racePosText = "\n ";
		}
		
		int lap = 1;
		if (competitor.currentLap > 0)
		{
			lap = competitor.currentLap;
		}
		
		if (theRace.laps == LAPS_Unlimited)
		{
			lapText = "\nlap " + lap + " / -";
		}
		else if (theRace.laps > 0)
		{
			lapText = "\nlap " + lap + " / " + theRace.laps;
		}
		else
		{
			lapText = "\nlap " + lap + " / 1";
		}
		
		if( theRace.laps == this.LAPS_Unlimited) //or theRace.laps < 1 ) //this.LAPS_NoLaps )
			game.updateDirectionArrow(theRace.raceName+"\ncheckpoint "+position+" / "+(theRace.checkPointsCount-1+"\n"+racePosText), vector3(v[0], v[1], v[2]));
		else
		{
			if( position == 0 )
				position = theRace.checkPointsCount;
			game.updateDirectionArrow(theRace.raceName+"\ncheckpoint "+position+" / "+(theRace.checkPointsCount+"\n"+lapText+racePosText), vector3(v[0], v[1], v[2]));
		}
	}

	void removeArrow()
	{
		game.hideDirectionArrow();
	}

	void setPenaltyTime(int raceID, int seconds)
	{
		this.raceDict[raceID].penaltyTime = seconds;
	}

	int getPenaltyTime(int raceID)
	{
		return this.raceDict[raceID].penaltyTime;
	}

	void setVersion(int raceID, const string &in version)
	{
		this.raceDict[raceID].setVersion(version);
	}

	void hideRace(int raceID)
	{
		this.raceDict[raceID].hide();
	}

	void unhideRace(int raceID)
	{
		this.raceDict[raceID].unhide();
	}

	void setStartNumber(int raceID, int startNum)
	{
		this.raceDict[raceID].startNum = startNum;
	}

	void resetEventCallback()
	{
		this.lastRaceEventInstance = "";
	}

	void finalize()
	{
		for( int raceID = 0; raceID < this.raceCount; ++raceID )
		{
			this.raceDict[raceID].loadRace(@this.raceDataFile);
		}
	}

	void finalize(int raceID)
	{
		loadRace(raceID);
	}

	// Internal function
	void saveRaces()
	{
		for( int raceID = 0; raceID < this.raceCount; ++raceID )
		{
			this.raceDict[raceID].saveRace(@this.raceDataFile);
		}

		this.raceDataFile.save();
	}

	void saveRace(int raceID)
	{
		//debug: game.log("saveRace(" + raceID + ")");
		this.raceDict[raceID].saveRace(@this.raceDataFile);
		this.raceDataFile.save();
	}


	void loadRace(int raceID)
	{
		this.raceDict[raceID].loadRace(@this.raceDataFile);
	}
}

// This class manages a race (singular!)
// this class shouldn't be edited!
// You should only use this directly if the races manager above doesn't suit your needs
// marked 'shared' so that other scripts can access the race data using `game.getScriptVariable()`
shared class raceBuilder {
	string raceName;
	double[][][] checkpoints;
	array<array<string>> objNames;
	int checkPointsCount;
	int id;
	double bestLapTime;
	double bestRaceTime;
	int laps;
	double[] bestTimeTillPoint;
	double[] lastTimeTillPoint;
	int finishNum;
	int startNum;
	int[] chpInstances; // needed to be able to remove races
	bool locked;
	bool completed;
	int penaltyTime;
	array<int> entrants;
	string raceVersion;
	bool isBuilt;
	bool awaitingRecycling;
	bool hidden;
	string raceBuilderVersion;
	string objNameCheckpoint;
	string objNameStart;
	string objNameFinish;

	raceBuilder(int id)
	{
		// game.log("raceBuilder::raceBuilder("+id+");");
		this.raceName = "No Name";
		this.checkPointsCount = 0;
		this.id = id;
		this.bestLapTime = 0.0;
		this.bestRaceTime = 0.0;
		this.laps = 0; /* racesManager::LAPS_NoLaps */
		this.finishNum = 0;
		this.startNum = 0;
		this.locked = false;
		this.completed = false;
		this.penaltyTime = 0;
		this.raceVersion = "unknown";
		this.awaitingRecycling = false;
		this.raceBuilderVersion = "RoR_RaceBuilder_v0.02";
		this.hidden = false;
	}

	void setVersion(const string &in version)
	{
		this.raceVersion = version;
	}

	void addChpCoordinates(double[][] checkpoints_in, const string &in objName_checkpoint, const string &in objName_start, const string &in objName_finish, uint startNumber)
	{
		// Remove empty coordinates at end
		for(int i=checkpoints_in.length()-1; i>=0; --i)
		{
			if(checkpoints_in[i].length()<3)
			{
				checkpoints_in.removeAt(i);
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: Checkpoint "+i+" ignored (did you put a comma too much after your last checkpoint?).");
			}
		}

		string oname = "chp-checkpoint";
		for( uint i = 0; i < checkpoints_in.length() ; i++ )
		{
			// check the coordinates, and try to correct them if possible
			if( checkpoints_in[i].length() < 3 )
			{
				game.log("Error in raceBuilder("+this.id+")::addChpCoordinates: A coordinate exists out of 6 numbers, "+checkpoints_in[i].length()+" found. Ingored checkpoint "+i+".");
				continue;
			}
			if( checkpoints_in[i].length() < 6 )
			{
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: A coordinate should exist out of 6 numbers. Padding with zeros.");
				checkpoints_in[i].resize(6);
				for( int k = checkpoints_in[i].length() ; k <=6 ; k++ )
				{
					checkpoints_in[i][k] = 0.0;
				}
			}
			if( checkpoints_in[i].length() > 6 )
			{
				game.log("Warning in raceBuilder("+this.id+")::addChpCoordinates: A coordinate should exist out of 6 numbers. Extra numbers dropped.");
				checkpoints_in[i].resize(6);
			}

			// Get the correct object name
			if( i == 0 )
				oname = objName_start;
			else if( ( i == checkpoints_in.length()-1 ) and ( this.laps == 0 /* racesManager::LAPS_NoLaps */) )
				oname = objName_finish;
			else
				oname = objName_checkpoint;

			this.addCheckpoint(startNumber+i, oname, checkpoints_in[i]);
		}

		// remember used object names for terrain editor conversion script
		this.objNameCheckpoint = objName_checkpoint;
		this.objNameStart = objName_start;
		this.objNameFinish = objName_finish;
	}

	int getNextCheckpointNum(int lastCheckpoint)
	{
		if( lastCheckpoint < this.checkPointsCount-1 )
			return lastCheckpoint+1;
		else if( lastCheckpoint == this.checkPointsCount-1 )
			return this.startNum;
		else
			game.log("ERROR in raceBuilder::getNextCheckpointNum: unhandled situation");
		return -1;
	}

	int getPreviousCheckpointNum(int lastCheckpoint)
	{
		if( lastCheckpoint > this.startNum )
		{
			return lastCheckpoint-1;
		}
		else if( (lastCheckpoint == this.startNum) and (this.laps == 0) /* racesManager::LAPS_NoLaps */)
		{
			return this.checkPointsCount-1;
		}
		else if( (lastCheckpoint == this.startNum) and (this.laps != 0) /* racesManager::LAPS_NoLaps */)
			return this.checkPointsCount-1;
		else
			game.log("ERROR in raceBuilder::getNextCheckpointNum: unhandled situation");
		return -1;
	}

	void addCheckpoint(int number, const string &in objName, const double[] &in v)
	{
		// debug: game.log("raceBuilder::addCheckpoint("+number+", \""+objName+"\", coords) called.");
		if( number > this.checkPointsCount )
		{
			game.log("Error in raceBuilder::addCheckpoint: Trying to add a checkpoint with a too high number ("+number+").");
			return;
		}
		else if( number < 0 )
		{
			game.log("Error in raceBuilder::addCheckpoint: The checkpoint number should positive.");
			return;
		}
		else if( number == this.checkPointsCount )
		{
			this.checkPointsCount++;
			if( this.laps == 0 /*racesManager::LAPS_NoLaps*/ )
				this.finishNum = this.checkPointsCount-1;
			this.bestTimeTillPoint.resize(this.checkPointsCount);
			this.bestTimeTillPoint[number] = 0.0;
			this.lastTimeTillPoint.resize(this.checkPointsCount);
			this.lastTimeTillPoint[number] = 0.0;
			this.chpInstances.resize(this.checkPointsCount);
			this.chpInstances[number] = 0;
			this.checkpoints.resize(this.checkPointsCount);
			this.objNames.resize(this.checkPointsCount);
		}
		this.checkpoints[number].resize(this.chpInstances[number]+1);
		this.checkpoints[number][this.chpInstances[number]] = v;
		this.objNames[number].resize(this.chpInstances[number]+1);
		this.objNames[number][this.chpInstances[number]] = objName;
		if( not this.hidden )
			game.spawnObject(objName, "checkpoint|"+this.id+"|"+number+"|"+this.chpInstances[number]++, vector3(v[0], v[1], v[2]), vector3(v[3], v[4], v[5]), "raceEvent", false);
	}

	void deleteCheckpoint(int number)
	{
		for( int i = this.chpInstances[number]-1; i >= 0; i-- )
		{
			this.deleteCheckpoint(number, i);
		}
	}

	// this gets the actual number of instances
	// (if you remove a checkpoint instance, then it may
	// get destroyed ingame, but the array may not always
	// get shortened.)
	uint getRealInstanceCount(int chpNum)
	{
		uint count = 0;
		for( int i = 0; i < this.chpInstances[chpNum]; i++ )
		{
			if( this.checkpoints[chpNum][i].length() != 0 )
				++count;
		}
		return count;
	}

	bool checkpointExists(int chpNum, int instance)
	{
		if(
			   ( uint(chpNum) >= this.checkpoints.length() )
			or ( chpNum < 0 )
			or ( instance >= this.chpInstances[chpNum] )
			or ( instance < 0 )
			or ( this.checkpoints[chpNum][instance].length() == 0 )
		)
			return false;
		else
			return true;
	}

	void deleteCheckpoint(int number, int instance)
	{
		if( not this.checkpointExists(number, instance) )
			return;

		// if this is the last instance of this checkpoint
		// and this is the last checkpoint
		// then we can really remove this checkpoint
		else if( ( this.getRealInstanceCount(number) == 1 ) and ( number == this.checkPointsCount-1 ) )
		{
			this.checkPointsCount--;
			this.bestTimeTillPoint.resize(this.checkPointsCount);
			this.lastTimeTillPoint.resize(this.checkPointsCount);
			this.chpInstances.resize(this.checkPointsCount);
			this.checkpoints.resize(this.checkPointsCount);
			this.objNames.resize(this.checkPointsCount);
			if( this.laps == 0 )
				this.finishNum = this.checkPointsCount-1;
		}

		// if the instance is the last added instance for this checkpoint
		// then we can remove it fully as well
		else if( this.chpInstances[number] == instance+1 )
		{
			this.chpInstances[number]--;
			this.checkpoints[number].resize(this.chpInstances[number]);
			this.objNames[number].resize(this.chpInstances[number]);
			while( ( this.chpInstances[number] > 0 ) and ( this.checkpoints[number][this.chpInstances[number]-1].length() == 0 ) )
			{
				this.chpInstances[number]--;
				this.checkpoints[number].resize(this.chpInstances[number]);
				this.objNames[number].resize(this.chpInstances[number]);
			}
		}

		else
		{
			this.checkpoints[number][instance].resize(0);
		}

		game.destroyObject("checkpoint|"+this.id+"|"+number+"|"+instance);
	}

	// this function removes all checkpoints again
	void destroy()
	{
		// game.log("raceBuilder::destroy() called for raceID "+this.id+".");
		this.hide();
		this.bestTimeTillPoint.resize(0);
		this.lastTimeTillPoint.resize(0);
		this.chpInstances.resize(0);
		this.checkpoints.resize(0);
		this.objNames.resize(0);
		this.checkPointsCount = 0;
		this.finishNum = 0;
		this.startNum = 0;
	}

	void hide()
	{
		if( this.hidden )
			return;
		else
			this.hidden = true;

		for(int i = 0 ; i<this.checkPointsCount ; i++)
		{
			for(int k = 0; k<this.chpInstances[i]; k++)
			{
				// game.log("game.destroyObject(checkpoint|"+this.id+"|"+i+"|"+k+");");
				if( this.checkpoints[i][k].length() != 0 )
					game.destroyObject("checkpoint|"+this.id+"|"+i+"|"+k);
			}
		}
	}

	void unhide()
	{
		if( not this.hidden )
			return;
		else
			this.hidden = false;

		for( int i = 0; i < this.checkPointsCount; i++ )
		{
			for( int k = 0; k < this.chpInstances[i]; k++ )
			{
				game.spawnObject(objNames[i][k], "checkpoint|"+this.id+"|"+i+"|"+k, vector3(this.checkpoints[i][k][0], this.checkpoints[i][k][1], this.checkpoints[i][k][2]), vector3(this.checkpoints[i][k][3], this.checkpoints[i][k][4], this.checkpoints[i][k][5]), "raceEvent", false);
			}
		}
	}

	void setLaps(int laps_in)
	{
		if( this.laps == laps_in )
			return;
		else if( this.checkPointsCount == 0 )
			this.laps = laps_in;
		else if( laps_in != 0 )
			this.finishNum = 0;
		else if( laps_in == 0 )
			this.finishNum = this.checkPointsCount-1;
	}

	bool isLocked()
	{
		return this.locked;
	}

	void saveRace(LocalStorageClass @d)
	{
		// Go to the correct section
		string terrain;
		game.getLoadedTerrain(terrain);
		int terrnPos = terrain.findFirst(".", 0);
		int racePos = raceName.findFirst(".", 0);
		d.changeSection(terrain.substr(0, terrnPos) + "--" + raceName.substr(0, racePos));

		// save all the data
		d.set("raceName", raceName);
		d.set("terrain", terrain);
		d.set("raceBuilderVersion", raceBuilderVersion);
		d.set("raceVersion", raceVersion);
		d.set("bestLapTime", bestLapTime);
		d.set("bestRaceTime", bestRaceTime);
		d.set("checkPointsCount", checkPointsCount);
		d.set("completed", completed);

		string tmp = "0.0";
		for( int i = 1; i < checkPointsCount; ++i )
		{
			tmp += ";"+bestTimeTillPoint[i];
		}
		d.set("bestTimeTillPoint", tmp);

		// For performance reasons, we don't save here yet.
	}

	void loadRace(LocalStorageClass@ d)
	{
		// Go to the correct section
		string terrain;
		game.getLoadedTerrain(terrain);
		int terrnPos = terrain.findFirst(".", 0);
		int racePos = raceName.findFirst(".", 0);
		d.changeSection(terrain.substr(0, terrnPos) + "--" + raceName.substr(0, racePos));

		// Only load the race if it's exactly the same
		// (this also returns if the race was never saved before)
		if( (d.get("raceName") != raceName)
			|| (d.get("terrain") != terrain)
			|| (d.get("raceBuilderVersion") != raceBuilderVersion)
			|| (d.get("raceVersion") != raceVersion)
			|| (d.getInt("checkPointsCount") != checkPointsCount)
		)
			return;

		// Load all the data
		bestLapTime = d.getFloat("bestLapTime");
		bestRaceTime = d.getFloat("bestRaceTime");
		completed = d.getBool("completed");
		string tmp = d.get("bestTimeTillPoint");

		int p1 = -1;
		uint p2 = 0;
		for( int i = 0; i < checkPointsCount; ++i )
		{
			p2 = tmp.findFirst(";", p1+1);
			bestTimeTillPoint[i] = parseFloat(tmp.substr(p1+1, p2-p1-1));
			p1 = p2;
		}
	}
}


// Class to hold one competitor's stats, to allow AI cars to compete in the same race as the player.
// marked 'shared' so that other scripts can access the race data using `game.getScriptVariable()`
shared class racesCompetitor {
	int currentRace;
	int currentLap;
	int lastRace;
	int truckNum;
	bool isThePlayer;
	bool hasAI;
	bool hasCameraFocus;
	int lastCheckpoint;
	int racePosition;
	int state;
	double raceStartTime;
	double lapStartTime;
	string lastCheckpointInstance;
	string lastRaceEventInstance;
	double lastRaceEventTime;
	double lastCheckpointTime;
	array<int> penaltyTime;
	double lastLapTime;
	double bestLapTime;
	double lastRaceTime;
	bool penaltyGiven;

// public functions
	
	// constructor
	racesCompetitor(int truckNum) {
		
		// we initialize the variables (do not edit these manually)
		this.truckNum = truckNum;
		this.isThePlayer = false;
		this.hasCameraFocus = false;
		this.state           = 0;// racesManager.STATE_NotInRace
		//this.raceCount       = 0;
		this.currentRace     = -1;
		this.currentLap       = 0;
		this.lastRace        = -1;
		this.lastCheckpoint   = 0;
		this.lastCheckpoint  = -1;
		this.racePosition     = 0;
		this.raceStartTime   = 0.0;
		this.lapStartTime    = 0.0;
		//this.cancelPointCount= 0;
		this.lastCheckpointInstance = "";
		this.lastRaceEventInstance = ""; // we only use this to boost the FPS
		//this.raceManagerVersion = "RoR_raceManager_v0.02";
		this.penaltyGiven = true;
		this.lastLapTime     = 0.0;
		this.lastCheckpointTime = 0.0;
		this.bestLapTime = 0.0;
		this.lastRaceTime = 0.0;
	}


}
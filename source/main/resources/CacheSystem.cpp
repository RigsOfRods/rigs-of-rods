/*
    This source file is part of Rigs of Rods
    Copyright 2005-2012 Pierre-Michel Ricordel
    Copyright 2007-2012 Thomas Fischer
    Copyright 2013-2023 Petr Ohlidal

    For more information, see http://www.rigsofrods.org/

    Rigs of Rods is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3, as
    published by the Free Software Foundation.

    Rigs of Rods is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Rigs of Rods. If not, see <http://www.gnu.org/licenses/>.
*/

/// @file   CacheSystem.h
/// @author Thomas Fischer, 21th of May 2008
/// @author Petr Ohlidal, 2018

#include "CacheSystem.h"

#include "Actor.h"
#include "AddonPartFileFormat.h"
#include "Application.h"
#include "SimData.h"
#include "ContentManager.h"
#include "ErrorUtils.h"
#include "GUI_LoadingWindow.h"
#include "GUI_GameMainMenu.h"
#include "GUIManager.h"
#include "GenericFileFormat.h"
#include "GfxActor.h"
#include "GfxScene.h"
#include "Language.h"
#include "PlatformUtils.h"
#include "RigDef_Parser.h"
#include "ScriptEngine.h"
#include "SkinFileFormat.h"
#include "Terrain.h"
#include "Terrn2FileFormat.h"
#include "TuneupFileFormat.h"
#include "Utils.h"

#include <OgreException.h>
#include <OgreFileSystem.h>
#include <OgreFileSystemLayer.h>
#include <rapidjson/document.h>
#include <rapidjson/istreamwrapper.h>
#include <rapidjson/ostreamwrapper.h>
#include <rapidjson/writer.h>
#include <fstream>

using namespace Ogre;
using namespace RoR;

CacheEntry::CacheEntry() :
    addtimestamp(0),
    beamcount(0),
    categoryid(CID_None),
    commandscount(0),
    custom_particles(false),
    customtach(false),
    deleted(false),
    driveable(NOT_DRIVEABLE),
    enginetype('t'), // enginetype = t = truck is default
    exhaustscount(0),
    fileformatversion(0),
    filetime(0),
    fixescount(0),
    flarescount(0),
    flexbodiescount(0),
    forwardcommands(false),
    hasSubmeshs(false),
    hydroscount(0),
    importcommands(false),
    loadmass(0),
    maxrpm(0),
    minrpm(0),
    nodecount(0),
    number(0),
    numgears(0),
    propscount(0),
    propwheelcount(0),
    rescuer(false),
    rotatorscount(0),
    shockcount(0),
    soundsourcescount(0),
    torque(0),
    truckmass(0),
    turbojetcount(0),
    turbopropscount(0),
    usagecounter(0),
    version(0),
    wheelcount(0),
    wingscount(0)
{
}

CacheEntry::~CacheEntry()
{
    // Destructs `TuneupDefPtr` which is a `RefCountingObjectPtr<>` so it doesn't compile without `#include "TuneupFileFormat.h"` and thus should not be in header.
}

CreateProjectRequest::CreateProjectRequest()
{
    // Constructs `ActorPtr` - doesn't compile without `#include Actor.h` - not pretty if in header (even if auto-generated by C++).
}

CreateProjectRequest::~CreateProjectRequest()
{
    // Destructs `ActorPtr` - doesn't compile without `#include Actor.h` - not pretty if in header (even if auto-generated by C++).
}

CacheQueryResult::CacheQueryResult(CacheEntryPtr entry, size_t score):
    cqr_entry(entry),
    cqr_score(score)
{}

CacheSystem::CacheSystem()
{
    // register the extensions
    m_known_extensions.push_back("machine");
    m_known_extensions.push_back("fixed");
    m_known_extensions.push_back("terrn2");
    m_known_extensions.push_back("truck");
    m_known_extensions.push_back("car");
    m_known_extensions.push_back("boat");
    m_known_extensions.push_back("airplane");
    m_known_extensions.push_back("trailer");
    m_known_extensions.push_back("load");
    m_known_extensions.push_back("train");
    m_known_extensions.push_back("skin");
    m_known_extensions.push_back("addonpart");
    m_known_extensions.push_back("tuneup");
    m_known_extensions.push_back("assetpack");

    // register the dirs
    m_content_dirs.push_back("mods");
    m_content_dirs.push_back("packs");
    m_content_dirs.push_back("terrains");
    m_content_dirs.push_back("vehicles");
    m_content_dirs.push_back("projects");
}

void CacheSystem::LoadModCache(CacheValidity validity)
{
    m_resource_paths.clear();
    m_update_time = getTimeStamp();

    if (validity != CacheValidity::VALID)
    {
        if (validity == CacheValidity::NEEDS_REBUILD)
        {
            RoR::Log("[RoR|ModCache] Performing rebuild ...");
            this->ClearCache();
        }
        else
        {
            RoR::Log("[RoR|ModCache] Performing update ...");
            this->ClearResourceGroups();
            this->PruneCache();
        }
        const bool orig_echo = App::diag_log_console_echo->getBool();
        App::diag_log_console_echo->setVal(false);
        this->ParseZipArchives(RGN_CONTENT);
        this->ParseKnownFiles(RGN_CONTENT);
        App::diag_log_console_echo->setVal(orig_echo);
        this->DetectDuplicates();
        this->WriteCacheFileJson();

        this->LoadCacheFileJson();
    }

    RoR::Log("[RoR|ModCache] Cache loaded");
    m_loaded = true;
}

CacheEntryPtr CacheSystem::FindEntryByFilename(LoaderType type, bool partial, const std::string& _filename_maybe_bundlequalified)
{
    // "Bundle-qualified" format also specifies the ZIP/directory in modcache, i.e. "mybundle.zip:myactor.truck"
    // Like the filename, the bundle name lookup is case-insensitive.
    // -------------------------------------------------------------------------------------------------

    std::string filename;
    std::string bundlename;
    SplitBundleQualifiedFilename(_filename_maybe_bundlequalified, bundlename, filename);
    StringUtil::toLowerCase(filename);
    StringUtil::toLowerCase(bundlename);
    size_t partial_match_length = std::numeric_limits<size_t>::max();
    CacheEntryPtr partial_match = nullptr;
    std::vector<CacheEntryPtr> log_candidates;
    for (CacheEntryPtr& entry : m_entries)
    {
        if ((type == LT_Terrain) != (entry->fext == "terrn2") ||
            (type == LT_AllBeam && entry->fext == "skin"))
            continue;

        String fname = entry->fname;
        String fname_without_uid = entry->fname_without_uid;
        String bname;
        String _path_placeholder;
        StringUtil::splitFilename(entry->resource_bundle_path, bname, _path_placeholder);
        StringUtil::toLowerCase(fname);
        StringUtil::toLowerCase(fname_without_uid);
        StringUtil::toLowerCase(bname);
        if (fname == filename || fname_without_uid == filename)
        {
            if (bundlename == "" || bname == bundlename)
            {
                return entry;
            }
            else
            {
                log_candidates.push_back(entry);
            }
        }
        else if (partial &&
            fname.length() < partial_match_length &&
            fname.find(filename) != std::string::npos)
        {
            if (bundlename == "" || bname == bundlename)
            {
                partial_match = entry;
                partial_match_length = fname.length();
            }
            else
            {
                log_candidates.push_back(entry);
            }
        }
    }

    if (log_candidates.size() > 0)
    {
        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_NOTICE,
            fmt::format(_LC("CacheSystem", "Mod '{}' was not found in cache; candidates ({}) are:"), _filename_maybe_bundlequalified, log_candidates.size()));
        for (CacheEntryPtr& entry: log_candidates)
        {
            std::string bundle_name, bundle_path;
            StringUtil::toLowerCase(bundle_name);
            Ogre::StringUtil::splitFilename(entry->resource_bundle_path, bundle_name, bundle_path);
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_NOTICE,
                fmt::format(_LC("CacheSystem", "* {}:{}"), bundle_name, entry->fname));
        }   
    }

    return (partial) ? partial_match : nullptr;
}

CacheValidity CacheSystem::EvaluateCacheValidity()
{
    this->GenerateHashFromFilenames();

    // Load cache file
    CacheValidity validity = this->LoadCacheFileJson();

    if (validity != CacheValidity::VALID)
    {
        RoR::Log("[RoR|ModCache] Cannot load cache file: wrong version, corrupted or missing.");
        return validity;
    }

    // Compare stored hash with generated hash
    if (m_filenames_hash_loaded != m_filenames_hash_generated)
    {
        RoR::Log("[RoR|ModCache] Cache file out of date");
        return CacheValidity::NEEDS_UPDATE;
    }

    for (auto& entry : m_entries)
    {
        std::string fn = entry->resource_bundle_path;
        if (entry->resource_bundle_type == "FileSystem")
        {
            fn = PathCombine(fn, entry->fname);
        }

        if ((entry->filetime != RoR::GetFileLastModifiedTime(fn)))
        {
            return CacheValidity::NEEDS_UPDATE;
        }
    }

    RoR::Log("[RoR|ModCache] Cache valid");
    return CacheValidity::VALID;
}

void CacheSystem::ImportEntryFromJson(rapidjson::Value& j_entry, CacheEntryPtr & out_entry)
{
    // Common details
    out_entry->usagecounter =           j_entry["usagecounter"].GetInt();
    out_entry->addtimestamp =           j_entry["addtimestamp"].GetInt();
    out_entry->resource_bundle_type =   j_entry["resource_bundle_type"].GetString();
    out_entry->resource_bundle_path =   j_entry["resource_bundle_path"].GetString();
    out_entry->fpath =                  j_entry["fpath"].GetString();
    out_entry->fname =                  j_entry["fname"].GetString();
    out_entry->fname_without_uid =      j_entry["fname_without_uid"].GetString();
    out_entry->fext =                   j_entry["fext"].GetString();
    out_entry->filetime =               j_entry["filetime"].GetInt();
    out_entry->dname =                  j_entry["dname"].GetString();
    out_entry->uniqueid =               j_entry["uniqueid"].GetString();
    out_entry->version =                j_entry["version"].GetInt();
    out_entry->filecachename =          j_entry["filecachename"].GetString();

    out_entry->guid = j_entry["guid"].GetString();
    Ogre::StringUtil::trim(out_entry->guid);

    // Category
    int category_id = j_entry["categoryid"].GetInt();
    auto category_itor = m_categories.find(category_id);
    if (category_itor == m_categories.end() || category_id >= CID_Max)
    {
        category_itor = m_categories.find(CID_Unsorted);
    }
    out_entry->categoryname = category_itor->second;
    out_entry->categoryid = category_itor->first;

     // Common - Authors
    for (rapidjson::Value& j_author: j_entry["authors"].GetArray())
    {
        AuthorInfo author;

        author.type  =  j_author["type"].GetString();
        author.name  =  j_author["name"].GetString();
        author.email =  j_author["email"].GetString();
        author.id    =  j_author["id"].GetInt();

        out_entry->authors.push_back(author);
    }

    // Vehicle details
    out_entry->description =       j_entry["description"].GetString();
    out_entry->tags =              j_entry["tags"].GetString();
    out_entry->default_skin =      j_entry["default_skin"].GetString();
    out_entry->fileformatversion = j_entry["fileformatversion"].GetInt();
    out_entry->hasSubmeshs =       j_entry["hasSubmeshs"].GetBool();
    out_entry->nodecount =         j_entry["nodecount"].GetInt();
    out_entry->beamcount =         j_entry["beamcount"].GetInt();
    out_entry->shockcount =        j_entry["shockcount"].GetInt();
    out_entry->fixescount =        j_entry["fixescount"].GetInt();
    out_entry->hydroscount =       j_entry["hydroscount"].GetInt();
    out_entry->wheelcount =        j_entry["wheelcount"].GetInt();
    out_entry->propwheelcount =    j_entry["propwheelcount"].GetInt();
    out_entry->commandscount =     j_entry["commandscount"].GetInt();
    out_entry->flarescount =       j_entry["flarescount"].GetInt();
    out_entry->propscount =        j_entry["propscount"].GetInt();
    out_entry->wingscount =        j_entry["wingscount"].GetInt();
    out_entry->turbopropscount =   j_entry["turbopropscount"].GetInt();
    out_entry->turbojetcount =     j_entry["turbojetcount"].GetInt();
    out_entry->rotatorscount =     j_entry["rotatorscount"].GetInt();
    out_entry->exhaustscount =     j_entry["exhaustscount"].GetInt();
    out_entry->flexbodiescount =   j_entry["flexbodiescount"].GetInt();
    out_entry->soundsourcescount = j_entry["soundsourcescount"].GetInt();
    out_entry->truckmass =         j_entry["truckmass"].GetFloat();
    out_entry->loadmass =          j_entry["loadmass"].GetFloat();
    out_entry->minrpm =            j_entry["minrpm"].GetFloat();
    out_entry->maxrpm =            j_entry["maxrpm"].GetFloat();
    out_entry->torque =            j_entry["torque"].GetFloat();
    out_entry->customtach =        j_entry["customtach"].GetBool();
    out_entry->custom_particles =  j_entry["custom_particles"].GetBool();
    out_entry->forwardcommands =   j_entry["forwardcommands"].GetBool();
    out_entry->importcommands =    j_entry["importcommands"].GetBool();
    out_entry->rescuer =           j_entry["rescuer"].GetBool();
    out_entry->driveable =         ActorType(j_entry["driveable"].GetInt());
    out_entry->numgears =          j_entry["numgears"].GetInt();
    out_entry->enginetype =        static_cast<char>(j_entry["enginetype"].GetInt());

    // Vehicle 'section-configs' (aka Modules in RigDef namespace)
    for (rapidjson::Value& j_module_name: j_entry["sectionconfigs"].GetArray())
    {
        out_entry->sectionconfigs.push_back(j_module_name.GetString());
    }

    // Addon part suggested mod guids
    for (rapidjson::Value& j_addonguid: j_entry["addonpart_guids"].GetArray())
    {
        out_entry->addonpart_guids.insert(j_addonguid.GetString());
    }

    // Addon part suggested mod filenames
    for (rapidjson::Value& j_addonfname: j_entry["addonpart_filenames"].GetArray())
    {
        out_entry->addonpart_filenames.insert(j_addonfname.GetString());
    }

    // Tuneup details
    out_entry->tuneup_associated_filename = j_entry["tuneup_associated_filename"].GetString();
}

CacheValidity CacheSystem::LoadCacheFileJson()
{
    // Clear existing entries
    m_entries.clear();

    rapidjson::Document j_doc;
    if (!App::GetContentManager()->LoadAndParseJson(CACHE_FILE, RGN_CACHE, j_doc) ||
        !j_doc.IsObject() || !j_doc.HasMember("entries") || !j_doc["entries"].IsArray())
    {
        RoR::Log("[RoR|ModCache] Error, cache file still invalid after check/update, content selector will be empty.");
        return CacheValidity::NEEDS_REBUILD;
    }

    if (j_doc["format_version"].GetInt() != CACHE_FILE_FORMAT)
    {
        RoR::Log("[RoR|ModCache] Invalid cache file format");
        return CacheValidity::NEEDS_REBUILD;
    }

    for (rapidjson::Value& j_entry: j_doc["entries"].GetArray())
    {
        CacheEntryPtr entry = new CacheEntry();
        this->ImportEntryFromJson(j_entry, entry);
        entry->number = static_cast<int>(m_entries.size() + 1); // Let's number mods from 1
        m_entries.push_back(entry);
    }

    m_filenames_hash_loaded = j_doc["global_hash"].GetString();

    return CacheValidity::VALID;
}

void CacheSystem::PruneCache()
{
    this->LoadCacheFileJson();

    std::vector<String> paths;
    for (auto& entry : m_entries)
    {
        std::string fn = entry->resource_bundle_path;
        if (entry->resource_bundle_type == "FileSystem")
        {
            fn = PathCombine(fn, entry->fname);
        }

        if (!RoR::FileExists(fn.c_str()) || (entry->filetime != RoR::GetFileLastModifiedTime(fn)))
        {
            if (!entry->deleted)
            {
                if (std::find(paths.begin(), paths.end(), fn) == paths.end())
                {
                    RoR::LogFormat("[RoR|ModCache] Removing '%s'", fn.c_str());
                    paths.push_back(fn);
                }
                this->RemoveFileCache(entry);
            }
            entry->deleted = true;
        }
        else
        {
            m_resource_paths.insert(fn);
        }
    }
}

void CacheSystem::ClearResourceGroups()
{
    for (auto& entry : m_entries)
    {
        String group = entry->resource_group;
        if (!group.empty())
        {
            if (ResourceGroupManager::getSingleton().resourceGroupExists(group))
                ResourceGroupManager::getSingleton().destroyResourceGroup(group);
        }
    }
}

void CacheSystem::DetectDuplicates()
{
    RoR::Log("[RoR|ModCache] Searching for duplicates ...");
    std::map<String, String> possible_duplicates;
    for (int i=0; i<m_entries.size(); i++) 
    {
        CacheEntryPtr entryA = m_entries[i];

        if (entryA->deleted)
            continue;

        String dnameA = entryA->dname;
        StringUtil::toLowerCase(dnameA);
        StringUtil::trim(dnameA);
        String dirA = entryA->resource_bundle_path;
        StringUtil::toLowerCase(dirA);
        String basenameA, basepathA;
        StringUtil::splitFilename(dirA, basenameA, basepathA);
        String filenameWUIDA = entryA->fname_without_uid;
        StringUtil::toLowerCase(filenameWUIDA);

        for (int j=i+1; j<m_entries.size(); j++) 
        {
            CacheEntryPtr entryB = m_entries[j];

            if (entryB->deleted)
                continue;

            String filenameWUIDB = entryB->fname_without_uid;
            StringUtil::toLowerCase(filenameWUIDB);
            if (filenameWUIDA != filenameWUIDB)
                continue;

            String dnameB = entryB->dname;
            StringUtil::toLowerCase(dnameB);
            StringUtil::trim(dnameB);
            if (dnameA != dnameB)
                continue;

            String dirB = entryB->resource_bundle_path;
            StringUtil::toLowerCase(dirB);
            String basenameB, basepathB;
            StringUtil::splitFilename(dirB, basenameB, basepathB);
            basenameA = Ogre::StringUtil::replaceAll(basenameA, " ", "_");
            basenameA = Ogre::StringUtil::replaceAll(basenameA, "-", "_");
            basenameB = Ogre::StringUtil::replaceAll(basenameB, " ", "_");
            basenameB = Ogre::StringUtil::replaceAll(basenameB, "-", "_");
            if (StripSHA1fromString(basenameA) != StripSHA1fromString(basenameB))
                continue;

            if (entryA->resource_bundle_path == entryB->resource_bundle_path)
            {
                LOG("- duplicate: " + entryA->fpath + entryA->fname
                             + " <--> " + entryB->fpath + entryB->fname);
                LOG("  - " + entryB->resource_bundle_path);
                int idx = entryA->fpath.size() < entryB->fpath.size() ? i : j;
                m_entries[idx]->deleted = true;
            }
            else
            {
                possible_duplicates[entryA->resource_bundle_path] = entryB->resource_bundle_path;
            }
        }
    }
    for (auto duplicate : possible_duplicates)
    {
        LOG("- possible duplicate: ");
        LOG("  - " + duplicate.first);
        LOG("  - " + duplicate.second);
    }
}

CacheEntryPtr CacheSystem::GetEntryByNumber(int modid)
{
    for (CacheEntryPtr& entry: m_entries)
    {
        if (modid == entry->number)
            return entry;
    }
    return 0;
}

String CacheSystem::GetPrettyName(String fname)
{
    for (CacheEntryPtr& entry: m_entries)
    {
        if (fname == entry->fname)
            return entry->dname;
    }
    return "";
}

std::string CacheSystem::ActorTypeToName(ActorType driveable)
{
    switch (driveable)
    {
    case ActorType::NOT_DRIVEABLE: return _LC("MainSelector", "Non-Driveable");
    case ActorType::TRUCK:         return _LC("MainSelector", "Truck");
    case ActorType::AIRPLANE:      return _LC("MainSelector", "Airplane");
    case ActorType::BOAT:          return _LC("MainSelector", "Boat");
    case ActorType::MACHINE:       return _LC("MainSelector", "Machine");
    case ActorType::AI:            return _LC("MainSelector", "A.I.");
    default:                       return "";
    };
}

void CacheSystem::ExportEntryToJson(rapidjson::Value& j_entries, rapidjson::Document& j_doc, CacheEntryPtr const & entry)
{
    rapidjson::Value j_entry(rapidjson::kObjectType);

    // Common details
    j_entry.AddMember("usagecounter",         entry->usagecounter,                                          j_doc.GetAllocator());
    j_entry.AddMember("addtimestamp",         static_cast<int64_t>(entry->addtimestamp),                    j_doc.GetAllocator());
    j_entry.AddMember("resource_bundle_type", rapidjson::StringRef(entry->resource_bundle_type.c_str()),    j_doc.GetAllocator());
    j_entry.AddMember("resource_bundle_path", rapidjson::StringRef(entry->resource_bundle_path.c_str()),    j_doc.GetAllocator());
    j_entry.AddMember("fpath",                rapidjson::StringRef(entry->fpath.c_str()),                   j_doc.GetAllocator());
    j_entry.AddMember("fname",                rapidjson::StringRef(entry->fname.c_str()),                   j_doc.GetAllocator());
    j_entry.AddMember("fname_without_uid",    rapidjson::StringRef(entry->fname_without_uid.c_str()),       j_doc.GetAllocator());
    j_entry.AddMember("fext",                 rapidjson::StringRef(entry->fext.c_str()),                    j_doc.GetAllocator());
    j_entry.AddMember("filetime",             static_cast<int64_t>(entry->filetime),                        j_doc.GetAllocator()); 
    j_entry.AddMember("dname",                rapidjson::StringRef(entry->dname.c_str()),                   j_doc.GetAllocator());
    j_entry.AddMember("categoryid",           entry->categoryid,                                            j_doc.GetAllocator());
    j_entry.AddMember("uniqueid",             rapidjson::StringRef(entry->uniqueid.c_str()),                j_doc.GetAllocator());
    j_entry.AddMember("guid",                 rapidjson::StringRef(entry->guid.c_str()),                    j_doc.GetAllocator());
    j_entry.AddMember("version",              entry->version,                                               j_doc.GetAllocator());
    j_entry.AddMember("filecachename",        rapidjson::StringRef(entry->filecachename.c_str()),           j_doc.GetAllocator());

    // Common - Authors
    rapidjson::Value j_authors(rapidjson::kArrayType);
    for (AuthorInfo const& author: entry->authors)
    {
        rapidjson::Value j_author(rapidjson::kObjectType);

        j_author.AddMember("type",   rapidjson::StringRef(author.type.c_str()),   j_doc.GetAllocator());
        j_author.AddMember("name",   rapidjson::StringRef(author.name.c_str()),   j_doc.GetAllocator());
        j_author.AddMember("email",  rapidjson::StringRef(author.email.c_str()),  j_doc.GetAllocator());
        j_author.AddMember("id",     author.id,                                   j_doc.GetAllocator());

        j_authors.PushBack(j_author, j_doc.GetAllocator());
    }
    j_entry.AddMember("authors", j_authors, j_doc.GetAllocator());

    // Vehicle details
    j_entry.AddMember("description",         rapidjson::StringRef(entry->description.c_str()),       j_doc.GetAllocator());
    j_entry.AddMember("tags",                rapidjson::StringRef(entry->tags.c_str()),              j_doc.GetAllocator());
    j_entry.AddMember("default_skin",        rapidjson::StringRef(entry->default_skin.c_str()),      j_doc.GetAllocator());
    j_entry.AddMember("fileformatversion",   entry->fileformatversion, j_doc.GetAllocator());
    j_entry.AddMember("hasSubmeshs",         entry->hasSubmeshs,       j_doc.GetAllocator());
    j_entry.AddMember("nodecount",           entry->nodecount,         j_doc.GetAllocator());
    j_entry.AddMember("beamcount",           entry->beamcount,         j_doc.GetAllocator());
    j_entry.AddMember("shockcount",          entry->shockcount,        j_doc.GetAllocator());
    j_entry.AddMember("fixescount",          entry->fixescount,        j_doc.GetAllocator());
    j_entry.AddMember("hydroscount",         entry->hydroscount,       j_doc.GetAllocator());
    j_entry.AddMember("wheelcount",          entry->wheelcount,        j_doc.GetAllocator());
    j_entry.AddMember("propwheelcount",      entry->propwheelcount,    j_doc.GetAllocator());
    j_entry.AddMember("commandscount",       entry->commandscount,     j_doc.GetAllocator());
    j_entry.AddMember("flarescount",         entry->flarescount,       j_doc.GetAllocator());
    j_entry.AddMember("propscount",          entry->propscount,        j_doc.GetAllocator());
    j_entry.AddMember("wingscount",          entry->wingscount,        j_doc.GetAllocator());
    j_entry.AddMember("turbopropscount",     entry->turbopropscount,   j_doc.GetAllocator());
    j_entry.AddMember("turbojetcount",       entry->turbojetcount,     j_doc.GetAllocator());
    j_entry.AddMember("rotatorscount",       entry->rotatorscount,     j_doc.GetAllocator());
    j_entry.AddMember("exhaustscount",       entry->exhaustscount,     j_doc.GetAllocator());
    j_entry.AddMember("flexbodiescount",     entry->flexbodiescount,   j_doc.GetAllocator());
    j_entry.AddMember("soundsourcescount",   entry->soundsourcescount, j_doc.GetAllocator());
    j_entry.AddMember("truckmass",           entry->truckmass,         j_doc.GetAllocator());
    j_entry.AddMember("loadmass",            entry->loadmass,          j_doc.GetAllocator());
    j_entry.AddMember("minrpm",              entry->minrpm,            j_doc.GetAllocator());
    j_entry.AddMember("maxrpm",              entry->maxrpm,            j_doc.GetAllocator());
    j_entry.AddMember("torque",              entry->torque,            j_doc.GetAllocator());
    j_entry.AddMember("customtach",          entry->customtach,        j_doc.GetAllocator());
    j_entry.AddMember("custom_particles",    entry->custom_particles,  j_doc.GetAllocator());
    j_entry.AddMember("forwardcommands",     entry->forwardcommands,   j_doc.GetAllocator());
    j_entry.AddMember("importcommands",      entry->importcommands,    j_doc.GetAllocator());
    j_entry.AddMember("rescuer",             entry->rescuer,           j_doc.GetAllocator());
    j_entry.AddMember("driveable",           entry->driveable,         j_doc.GetAllocator());
    j_entry.AddMember("numgears",            entry->numgears,          j_doc.GetAllocator());
    j_entry.AddMember("enginetype",          entry->enginetype,        j_doc.GetAllocator());

    // Vehicle 'section-configs' (aka Modules in RigDef namespace)
    rapidjson::Value j_sectionconfigs(rapidjson::kArrayType);
    for (std::string const & module_name: entry->sectionconfigs)
    {
        j_sectionconfigs.PushBack(rapidjson::StringRef(module_name.c_str()), j_doc.GetAllocator());
    }
    j_entry.AddMember("sectionconfigs", j_sectionconfigs, j_doc.GetAllocator());

    // Addon part details
    rapidjson::Value j_addonguids(rapidjson::kArrayType);
    for (std::string const & ag: entry->addonpart_guids)
    {
        j_addonguids.PushBack(rapidjson::StringRef(ag.c_str()), j_doc.GetAllocator());
    }
    j_entry.AddMember("addonpart_guids", j_addonguids, j_doc.GetAllocator());

    rapidjson::Value j_addonfnames(rapidjson::kArrayType);
    for (std::string const & ag: entry->addonpart_filenames)
    {
        j_addonfnames.PushBack(rapidjson::StringRef(ag.c_str()), j_doc.GetAllocator());
    }
    j_entry.AddMember("addonpart_filenames", j_addonfnames, j_doc.GetAllocator());

    // Tuneup details
    j_entry.AddMember("tuneup_associated_filename", rapidjson::StringRef(entry->tuneup_associated_filename.c_str()), j_doc.GetAllocator());

    // Add entry to list
    j_entries.PushBack(j_entry, j_doc.GetAllocator());
}

void CacheSystem::WriteCacheFileJson()
{
    // Basic file structure
    rapidjson::Document j_doc;
    j_doc.SetObject();
    j_doc.AddMember("format_version", CACHE_FILE_FORMAT, j_doc.GetAllocator());
    j_doc.AddMember("global_hash", rapidjson::StringRef(m_filenames_hash_generated.c_str()), j_doc.GetAllocator());

    // Entries
    rapidjson::Value j_entries(rapidjson::kArrayType);
    for (CacheEntryPtr const& entry : m_entries)
    {
        if (!entry->deleted)
        {
            this->ExportEntryToJson(j_entries, j_doc, entry);
        }
    }
    j_doc.AddMember("entries", j_entries, j_doc.GetAllocator());

    // Write to file
    if (App::GetContentManager()->SerializeAndWriteJson(CACHE_FILE, RGN_CACHE, j_doc)) // Logs errors
    {
        RoR::LogFormat("[RoR|ModCache] File '%s' written OK", CACHE_FILE);
    }
}

void CacheSystem::ClearCache()
{
    App::GetContentManager()->DeleteDiskFile(CACHE_FILE, RGN_CACHE);
    for (auto& entry : m_entries)
    {
        String group = entry->resource_group;
        if (!group.empty())
        {
            if (ResourceGroupManager::getSingleton().resourceGroupExists(group))
                ResourceGroupManager::getSingleton().destroyResourceGroup(group);
        }
        this->RemoveFileCache(entry);
    }
    m_entries.clear();
}

Ogre::String CacheSystem::StripUIDfromString(Ogre::String uidstr)
{
    size_t pos = uidstr.find("-");
    if (pos != String::npos && pos >= 3 && uidstr.substr(pos - 3, 3) == "UID")
        return uidstr.substr(pos + 1, uidstr.length() - pos);
    return uidstr;
}

Ogre::String CacheSystem::StripSHA1fromString(Ogre::String sha1str)
{
    size_t pos = sha1str.find_first_of("-_");
    if (pos != String::npos && pos >= 20)
        return sha1str.substr(pos + 1, sha1str.length() - pos);
    return sha1str;
}

void CacheSystem::AddFile(String group, Ogre::FileInfo f, String ext)
{
    String type = f.archive ? f.archive->getType() : "FileSystem";
    String path = f.archive ? f.archive->getName() : "";

    if (std::find_if(m_entries.begin(), m_entries.end(), [&](CacheEntryPtr& entry)
                { return !entry->deleted && entry->fname == f.filename && entry->resource_bundle_path == path; }) != m_entries.end())
        return;

    RoR::LogFormat("[RoR|CacheSystem] Preparing to add file '%f'", f.filename.c_str());

    try
    {
        DataStreamPtr ds = ResourceGroupManager::getSingleton().openResource(f.filename, group);
        // ds closes automatically, so do _not_ close it explicitly below

        std::vector<CacheEntryPtr> new_entries;
        if (ext == "terrn2")
        {
            CacheEntryPtr entry = new CacheEntry();
            FillTerrainDetailInfo(entry, ds, f.filename);
            new_entries.push_back(entry);
        }
        else if (ext == "skin")
        {
            auto new_skins = RoR::SkinParser::ParseSkins(ds);
            for (auto skin_def: new_skins)
            {
                CacheEntryPtr entry = new CacheEntry();
                FillSkinDetailInfo(entry, skin_def);
                new_entries.push_back(entry);
            }
        }
        else if (ext == "addonpart")
        {
            CacheEntryPtr entry = new CacheEntry();
            FillAddonPartDetailInfo(entry, ds);
            new_entries.push_back(entry);
        }
        else if (ext == "tuneup")
        {
            auto new_tuneups = RoR::TuneupUtil::ParseTuneups(ds);
            for (auto tuneup_def: new_tuneups)
            {
                CacheEntryPtr entry = new CacheEntry();
                FillTuneupDetailInfo(entry, tuneup_def);
                new_entries.push_back(entry);
            }
        }
        else if (ext == "assetpack")
        {
            CacheEntryPtr entry = new CacheEntry();
            FillAssetPackDetailInfo(entry, ds);
            new_entries.push_back(entry);
        }
        else
        {
            CacheEntryPtr entry = new CacheEntry();
            FillTruckDetailInfo(entry, ds, f.filename, group);
            new_entries.push_back(entry);
        }

        for (auto& entry: new_entries)
        {
            Ogre::StringUtil::toLowerCase(entry->guid); // Important for comparsion
            entry->fpath = f.path;
            entry->fname = f.filename;
            entry->fname_without_uid = StripUIDfromString(f.filename);
            entry->fext = ext;
            if (type == "Zip")
            {
                entry->filetime = RoR::GetFileLastModifiedTime(path);
            }
            else
            {
                entry->filetime = RoR::GetFileLastModifiedTime(PathCombine(path, f.filename));
            }
            entry->resource_bundle_type = type;
            entry->resource_bundle_path = path;
            entry->number = static_cast<int>(m_entries.size() + 1); // Let's number mods from 1
            entry->addtimestamp = m_update_time;
            this->GenerateFileCache(entry, group);
            m_entries.push_back(entry);
        }
    }
    catch (Ogre::Exception& e)
    {
        RoR::LogFormat("[RoR|CacheSystem] Error processing file '%s', message :%s",
            f.filename.c_str(), e.getFullDescription().c_str());
    }
}

void CacheSystem::FillTruckDetailInfo(CacheEntryPtr& entry, Ogre::DataStreamPtr stream, String file_name, String group)
{
    /* LOAD AND PARSE THE VEHICLE */
    RigDef::Parser parser;
    parser.Prepare();
    parser.ProcessOgreStream(stream.getPointer(), group);
    parser.GetSequentialImporter()->Disable();
    parser.Finalize();

    /* RETRIEVE DATA */

    RigDef::DocumentPtr def = parser.GetFile();

    /* Name */
    if (!def->name.empty())
    {
        entry->dname = def->name; // Use retrieved name
    }
    else
    {
        entry->dname = "@" + file_name; // Fallback
    }

    /* Description */
    std::vector<Ogre::String>::iterator desc_itor = def->root_module->description.begin();
    for (; desc_itor != def->root_module->description.end(); desc_itor++)
    {
        entry->description += *desc_itor + "\n";
    }

    /* Authors */
    std::vector<RigDef::Author>::iterator author_itor = def->root_module->author.begin();
    for (; author_itor != def->root_module->author.end(); author_itor++)
    {
        AuthorInfo author;
        author.email = author_itor->email;
        author.id = (author_itor->_has_forum_account) ? static_cast<int>(author_itor->forum_account_id) : -1;
        author.name = author_itor->name;
        author.type = author_itor->type;

        entry->authors.push_back(author);
    }

    /* Default skin */
    if (def->root_module->default_skin.size() > 0)
    {
        entry->default_skin = def->root_module->default_skin.back().skin_name;
    }

    /* Modules (previously called "sections") */
    std::map<Ogre::String, std::shared_ptr<RigDef::Document::Module>>::iterator module_itor = def->user_modules.begin();
    for (; module_itor != def->user_modules.end(); module_itor++)
    {
        entry->sectionconfigs.push_back(module_itor->second->name);
    }

    /* Engine */
    /* TODO: Handle engines in modules */
    if (def->root_module->engine.size() > 0)
    {
        RigDef::Engine& engine = def->root_module->engine[def->root_module->engine.size() - 1];
        entry->numgears = static_cast<int>(engine.gear_ratios.size());
        entry->minrpm = engine.shift_down_rpm;
        entry->maxrpm = engine.shift_up_rpm;
        entry->torque = engine.torque;
        entry->enginetype = 't'; /* Truck (default) */
        if (def->root_module->engoption.size() > 0)
        {
            entry->enginetype = (char)def->root_module->engoption[def->root_module->engoption.size() - 1].type;
        }
    }

    /* File info */
    if (def->root_module->fileinfo.size() > 0)
    {
        RigDef::Fileinfo& data = def->root_module->fileinfo[def->root_module->fileinfo.size() - 1];

        entry->uniqueid = data.unique_id;
        entry->categoryid = static_cast<int>(data.category_id);
        entry->version = static_cast<int>(data.file_version);
    }
    else
    {
        entry->uniqueid = "-1";
        entry->categoryid = -1;
        entry->version = -1;
    }

    /* Vehicle type */
    /* NOTE: RigDef::Document allows modularization of vehicle type. Cache only supports single type.
        This is a temporary solution which has undefined results for mixed-type vehicles.
    */
    ActorType vehicle_type = NOT_DRIVEABLE;
    module_itor = def->user_modules.begin();
    for (; module_itor != def->user_modules.end(); module_itor++)
    {
        if (module_itor->second->engine.size() > 0)
        {
            vehicle_type = TRUCK;
        }
        else if (module_itor->second->screwprops.size() > 0)
        {
            vehicle_type = BOAT;
        }
        /* Note: Sections 'turboprops' and 'turboprops2' are unified in TruckParser2013 */
        else if (module_itor->second->turbojets.size() > 0 || module_itor->second->pistonprops.size() > 0 || module_itor->second->turboprops2.size() > 0)
        {
            vehicle_type = AIRPLANE;
        }
    }
    /* Root module */
    if (def->root_module->engine.size() > 0)
    {
        vehicle_type = TRUCK;
    }
    else if (def->root_module->screwprops.size() > 0)
    {
        vehicle_type = BOAT;
    }
    /* Note: Sections 'turboprops' and 'turboprops2' are unified in TruckParser2013 */
    else if (def->root_module->turbojets.size() > 0 || def->root_module->pistonprops.size() > 0 || def->root_module->turboprops2.size() > 0)
    {
        vehicle_type = AIRPLANE;
    }

    if (def->root_module->globals.size() > 0)
    {
        entry->truckmass = def->root_module->globals[def->root_module->globals.size() - 1].dry_mass;
        entry->loadmass = def->root_module->globals[def->root_module->globals.size() - 1].cargo_mass;
    }
    
    entry->forwardcommands = def->forward_commands;
    entry->importcommands = def->import_commands;
    entry->rescuer = def->rescuer;
    if (def->root_module->guid.size() > 0)
    {
        entry->guid = def->root_module->guid[def->root_module->guid.size() - 1].guid;
        Ogre::StringUtil::toLowerCase(entry->guid);
    }
    entry->fileformatversion = 0;
    if (def->root_module->fileformatversion.size() > 0)
    {
        entry->fileformatversion = def->root_module->fileformatversion[def->root_module->fileformatversion.size() - 1].version;
    }
    entry->hasSubmeshs = static_cast<int>(def->root_module->submeshes.size() > 0);
    entry->nodecount = static_cast<int>(def->root_module->nodes.size());
    entry->beamcount = static_cast<int>(def->root_module->beams.size());
    entry->shockcount = static_cast<int>(def->root_module->shocks.size() + def->root_module->shocks2.size());
    entry->fixescount = static_cast<int>(def->root_module->fixes.size());
    entry->hydroscount = static_cast<int>(def->root_module->hydros.size());
    entry->driveable = vehicle_type;
    entry->commandscount = static_cast<int>(def->root_module->commands2.size());
    entry->flarescount = static_cast<int>(def->root_module->flares2.size());
    entry->propscount = static_cast<int>(def->root_module->props.size());
    entry->wingscount = static_cast<int>(def->root_module->wings.size());
    entry->turbopropscount = static_cast<int>(def->root_module->turboprops2.size());
    entry->rotatorscount = static_cast<int>(def->root_module->rotators.size() + def->root_module->rotators2.size());
    entry->exhaustscount = static_cast<int>(def->root_module->exhausts.size());
    entry->custom_particles = def->root_module->particles.size() > 0;
    entry->turbojetcount = static_cast<int>(def->root_module->turbojets.size());
    entry->flexbodiescount = static_cast<int>(def->root_module->flexbodies.size());
    entry->soundsourcescount = static_cast<int>(def->root_module->soundsources.size() + def->root_module->soundsources.size());

    entry->wheelcount = 0;
    entry->propwheelcount = 0;
    for (const auto& w : def->root_module->wheels)
    {
        entry->wheelcount++;
        if (w.propulsion != RigDef::WheelPropulsion::NONE)
            entry->propwheelcount++;
    }
    for (const auto& w : def->root_module->wheels2)
    {
        entry->wheelcount++;
        if (w.propulsion != RigDef::WheelPropulsion::NONE)
            entry->propwheelcount++;
    }
    for (const auto& w : def->root_module->meshwheels)
    {
        entry->wheelcount++;
        if (w.propulsion != RigDef::WheelPropulsion::NONE)
            entry->propwheelcount++;
    }
    for (const auto& w : def->root_module->meshwheels2)
    {
        entry->wheelcount++;
        if (w.propulsion != RigDef::WheelPropulsion::NONE)
            entry->propwheelcount++;
    }
    for (const auto& w : def->root_module->flexbodywheels)
    {
        entry->wheelcount++;
        if (w.propulsion != RigDef::WheelPropulsion::NONE)
            entry->propwheelcount++;
    }

    if (!def->root_module->axles.empty())
    {
        entry->propwheelcount = static_cast<int>(def->root_module->axles.size() * 2);
    }

    /* NOTE: std::shared_ptr cleans everything up. */
}

Ogre::String detectMiniType(String filename, String group)
{
    if (ResourceGroupManager::getSingleton().resourceExists(group, filename + "dds"))
        return "dds";

    if (ResourceGroupManager::getSingleton().resourceExists(group, filename + "png"))
        return "png";

    if (ResourceGroupManager::getSingleton().resourceExists(group, filename + "jpg"))
        return "jpg";

    return "";
}

void CacheSystem::RemoveFileCache(CacheEntryPtr& entry)
{
    if (!entry->filecachename.empty())
    {
        App::GetContentManager()->DeleteDiskFile(entry->filecachename, RGN_CACHE);
    }
}

void CacheSystem::GenerateFileCache(CacheEntryPtr& entry, String group)
{
    if (entry->fname.empty())
        return;

    String bundle_basename, bundle_path;
    StringUtil::splitFilename(entry->resource_bundle_path, bundle_basename, bundle_path);

    String src_path;
    String dst_path;
    if (entry->fext == "skin")
    {
        if (entry->skin_def->thumbnail.empty())
            return;
        src_path = entry->skin_def->thumbnail;
        String mini_fbase, minitype;
        StringUtil::splitBaseFilename(entry->skin_def->thumbnail, mini_fbase, minitype);
        dst_path = bundle_basename + "_" + mini_fbase + ".mini." + minitype;
    }
    else
    {
        String fbase, fext;
        StringUtil::splitBaseFilename(entry->fname, fbase, fext);
        String minifn = fbase + "-mini.";
        String minitype = detectMiniType(minifn, group);
        if (minitype.empty())
            return;
        src_path = minifn + minitype;
        dst_path = bundle_basename + "_" + entry->fname + ".mini." + minitype;
    }

    try
    {
        DataStreamPtr src_ds = ResourceGroupManager::getSingleton().openResource(src_path, group);
        DataStreamPtr dst_ds = ResourceGroupManager::getSingleton().createResource(dst_path, RGN_CACHE, true);
        std::vector<char> buf(src_ds->size());
        size_t read = src_ds->read(buf.data(), src_ds->size());
        if (read > 0)
        {
            dst_ds->write(buf.data(), read); 
            entry->filecachename = dst_path;
        }
    }
    catch (Ogre::Exception& e)
    {
        LOG("error while generating file cache: " + e.getFullDescription());
    }

    LOG("done generating file cache!");
}

void CacheSystem::ParseZipArchives(String group)
{
    auto files = ResourceGroupManager::getSingleton().findResourceFileInfo(group, "*.zip");
    auto skinzips = ResourceGroupManager::getSingleton().findResourceFileInfo(group, "*.skinzip");
    for (const auto& skinzip : *skinzips)
        files->push_back(skinzip);

    int i = 0, count = static_cast<int>(files->size());
    for (const auto& file : *files)
    {
        int progress = ((float)i++ / (float)count) * 100;
        std::string text = fmt::format("{}{}\n{}\n{}/{}",
            _L("Loading zips in group "), group, file.filename, i, count);
        RoR::App::GetGuiManager()->LoadingWindow.SetProgress(progress, text);

        String path = PathCombine(file.archive->getName(), file.filename);
        this->ParseSingleZip(path);
    }

    RoR::App::GetGuiManager()->LoadingWindow.SetVisible(false);
    App::GetGuiManager()->GameMainMenu.CacheUpdatedNotice();
}

void CacheSystem::ParseSingleZip(String path)
{
    if (std::find(m_resource_paths.begin(), m_resource_paths.end(), path) == m_resource_paths.end())
    {
        RoR::LogFormat("[RoR|ModCache] Adding archive '%s'", path.c_str());
        ResourceGroupManager::getSingleton().createResourceGroup(RGN_TEMP, false);
        try
        {
            ResourceGroupManager::getSingleton().addResourceLocation(path, "Zip", RGN_TEMP);
            if (ParseKnownFiles(RGN_TEMP))
            {
                LOG("No usable content in: '" + path + "'");
            }
        }
        catch (Ogre::Exception& e)
        {
            LOG("Error while opening archive: '" + path + "': " + e.getFullDescription());
        }
        ResourceGroupManager::getSingleton().destroyResourceGroup(RGN_TEMP);
        m_resource_paths.insert(path);
    }
}

bool CacheSystem::ParseKnownFiles(Ogre::String group)
{
    bool empty = true;
    for (auto ext : m_known_extensions)
    {
        auto files = ResourceGroupManager::getSingleton().findResourceFileInfo(group, "*." + ext);
        for (const auto& file : *files)
        {
            this->AddFile(group, file, ext);
            empty = false;
        }
    }
    return empty;
}

void CacheSystem::GenerateHashFromFilenames()
{
    std::string filenames = App::GetContentManager()->ListAllUserContent();
    m_filenames_hash_generated = HashData(filenames.c_str(), static_cast<int>(filenames.size()));
}

void CacheSystem::FillTerrainDetailInfo(CacheEntryPtr& entry, Ogre::DataStreamPtr ds, Ogre::String fname)
{
    Terrn2Def def;
    Terrn2Parser parser;
    parser.LoadTerrn2(def, ds);

    for (Terrn2Author& author : def.authors)
    {
        AuthorInfo a;
        a.id = -1;
        a.name = author.name;
        a.type = author.type;
        entry->authors.push_back(a);
    }

    entry->dname      = def.name;
    entry->categoryid = def.category_id;
    entry->uniqueid   = def.guid;
    entry->version    = def.version;
}

void CacheSystem::FillSkinDetailInfo(CacheEntryPtr &entry, std::shared_ptr<SkinDef>& skin_def)
{
    if (!skin_def->author_name.empty())
    {
        AuthorInfo a;
        a.id = skin_def->author_id;
        a.name = skin_def->author_name;
        entry->authors.push_back(a);
    }

    entry->dname       = skin_def->name;
    entry->guid        = skin_def->guid;
    entry->description = skin_def->description;
    entry->categoryid  = -1;
    entry->skin_def    = skin_def; // Needed to generate preview image

    Ogre::StringUtil::toLowerCase(entry->guid);
}

void CacheSystem::FillAddonPartDetailInfo(CacheEntryPtr &entry, Ogre::DataStreamPtr ds)
{
    GenericDocumentPtr doc = new GenericDocument();
    BitMask_t options = GenericDocument::OPTION_ALLOW_SLASH_COMMENTS | GenericDocument::OPTION_ALLOW_NAKED_STRINGS;
    doc->loadFromDataStream(ds, options);

    GenericDocContextPtr ctx = new GenericDocContext(doc);
    while (!ctx->endOfFile())
    {
        if (ctx->isTokKeyword() && ctx->getTokKeyword() == "addonpart_name")
        {
            entry->dname = ctx->getTokString(1);
        }
        else if (ctx->isTokKeyword() && ctx->getTokKeyword() == "addonpart_description")
        {
            entry->description = ctx->getTokString(1);
        }
        else if (ctx->isTokKeyword() && ctx->getTokKeyword() == "addonpart_guid")
        {
            std::string guid = ctx->getTokString(1);
            Ogre::StringUtil::toLowerCase(guid);
            entry->addonpart_guids.insert(guid);
        }
        else if (ctx->isTokKeyword() && ctx->getTokKeyword() == "addonpart_filename")
        {
            std::string fname = ctx->getTokString(1);
            Ogre::StringUtil::toLowerCase(fname);
            entry->addonpart_filenames.insert(fname);
        }

        ctx->seekNextLine();
    }
}

void CacheSystem::FillAssetPackDetailInfo(CacheEntryPtr &entry, Ogre::DataStreamPtr ds)
{
    GenericDocumentPtr doc = new GenericDocument();
    BitMask_t options = GenericDocument::OPTION_ALLOW_SLASH_COMMENTS | GenericDocument::OPTION_ALLOW_NAKED_STRINGS;
    doc->loadFromDataStream(ds, options);

    GenericDocContextPtr ctx = new GenericDocContext(doc);
    while (!ctx->endOfFile())
    {
        if (ctx->isTokKeyword() && ctx->getTokKeyword() == "assetpack_name")
        {
            entry->dname = ctx->getTokString(1);
        }
        else if (ctx->isTokKeyword() && ctx->getTokKeyword() == "assetpack_description")
        {
            entry->description = ctx->getTokString(1);
        }
        else if (ctx->isTokKeyword() && ctx->getTokKeyword() == "assetpack_author")
        {
            int n = ctx->countLineArgs();
            AuthorInfo author;
            if (n > 1) { author.type             = ctx->getTokString(1); }
            if (n > 2) { author.id               = (int)ctx->getTokFloat(2); }
            if (n > 3) { author.name             = ctx->getTokString(3); }
            if (n > 4) { author.email            = ctx->getTokString(4); }
            entry->authors.push_back(author);
        }

        ctx->seekNextLine();
    }
}

void CacheSystem::FillTuneupDetailInfo(CacheEntryPtr &entry, TuneupDefPtr& tuneup_def)
{
    if (!tuneup_def->author_name.empty())
    {
        AuthorInfo a;
        a.id = tuneup_def->author_id;
        a.name = tuneup_def->author_name;
        entry->authors.push_back(a);
    }

    entry->dname       = tuneup_def->name;
    entry->guid        = tuneup_def->guid;
    entry->description = tuneup_def->description;
    entry->categoryid  = tuneup_def->category_id;
    entry->tuneup_def  = tuneup_def; // Needed to generate preview image
    entry->tuneup_associated_filename = tuneup_def->filename;

    Ogre::StringUtil::toLowerCase(entry->guid);
    Ogre::StringUtil::toLowerCase(entry->tuneup_associated_filename);
}

void CacheSystem::LoadAssetPack(CacheEntryPtr& target_entry, Ogre::String const & assetpack_filename)
{
    // Load asset packs into the mod-bundle's resource group (quick & dirty approach).
    // See also `ContentManager::resourceCollision()` - we always keep the original file and dump the colliding one.
    // --------------------------------------------------------------------------------------------------------------

    ROR_ASSERT(!target_entry->deleted);
    ROR_ASSERT(target_entry->resource_group != "");
    ROR_ASSERT(assetpack_filename != "");

    CacheEntryPtr assetpack_entry = App::GetCacheSystem()->FindEntryByFilename(LT_AssetPack, /*partial=*/false, assetpack_filename);
    if (assetpack_entry)
    {
        try
        {
            Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
                assetpack_entry->resource_bundle_path, // name (source)
                assetpack_entry->resource_bundle_type, // type (source)
                target_entry->resource_group, // resGroup (target)
                false, // recursive
                assetpack_entry->resource_bundle_type != "FileSystem"); // readOnly

            // This is messy but there's no other way - OGRE resource groups cannot update incrementally.
            Ogre::ResourceGroupManager::getSingleton().clearResourceGroup(target_entry->resource_group);
            Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(target_entry->resource_group);
        }
        catch (std::exception const& e)
        {
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_TERRN, Console::CONSOLE_SYSTEM_ERROR,
                fmt::format(_L("Failed to load asset pack '{}' (requested by '{}'): {}"), assetpack_entry->fname, target_entry->fname, e.what()));
        }
    }
    else
    {
        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_TERRN, Console::CONSOLE_SYSTEM_WARNING, 
            fmt::format(_L("Asset pack '{}' (requested by '{}') not found"), assetpack_filename, target_entry->fname));
    }
}

static bool CheckAndReplacePathIgnoreCase(const CacheEntryPtr& entry, CVar* dir, const std::string& dir_label, std::string& out_rgname)
{
    // Helper for `ComposeResourceGroupName()`
    // ---------------------------------------

    // Sanity check - assert on Debug, minimize damage on Release
    ROR_ASSERT(entry->resource_bundle_path != "");
    if (entry->resource_bundle_path == "")
    {
        LOG(fmt::format("[RoR|CacheSystem] CheckAndReplacePathIgnoreCase(): INTERNAL ERROR - entry '{}' has no bundle path!", entry->fname));
        return false;
    }

    // Lowercase everything
    std::string lower_bundlepath = entry->resource_bundle_path;
    Ogre::StringUtil::toLowerCase(lower_bundlepath);

    std::string lower_dir = dir->getStr();
    Ogre::StringUtil::toLowerCase(lower_dir);    

    // Look for match and replace
    if (Ogre::StringUtil::startsWith(lower_bundlepath, lower_dir, /*lowercase:*/true))
    {
        // Sanity check; Should be guaranteed by the `startsWith()` check, but just to be sure...
        ROR_ASSERT(lower_bundlepath.size() > lower_dir.size());
        if (lower_bundlepath.size() > lower_dir.size())
        {
            std::string localpath = entry->resource_bundle_path.substr(lower_dir.length());
            out_rgname = fmt::format("{{bundle {}:{}}}", dir_label, localpath);
            return true;
        }
    }
    return false;
}

std::string CacheSystem::ComposeResourceGroupName(const CacheEntryPtr& entry)
{
    // Compose group name as "{bundle <local path>}", where 'local path' means either:
    // - under `sys_user_dir` (by default 'Documenst\My Games\Rigs of Rods')
    // - under `app_extra_mod_path` (empty by default)
    // - under 'sys_process_dir' (autodetected)
    // -------------------------------------------------------------------------------

    std::string rg_name;
    if (CheckAndReplacePathIgnoreCase(entry, App::sys_user_dir, "USER", rg_name) ||
        CheckAndReplacePathIgnoreCase(entry, App::sys_process_dir, "BIN", rg_name) ||
        CheckAndReplacePathIgnoreCase(entry, App::app_extra_mod_path, "EXTRA", rg_name))
    {
        return rg_name;
    }
    else
    {
        return fmt::format("{{bundle FULL:{}}}", entry->resource_bundle_path);
    }
}

void CacheSystem::LoadSupplementaryDocuments(CacheEntryPtr& entry)
{
    // Because we use one resource group per bundle and multiple entries can share the same bundle,
    //  we need to load the supplementary documents even if the bundle is already loaded.
    // -------------------------------------------------------------------------------------------

    if (!entry)
        return;

    ROR_ASSERT(entry->resource_group != "");

    if (entry->fext == "skin")
    {
        this->LoadAssociatedSkinDef(entry);
    }
    else if (entry->fext == "tuneup")
    {
        this->LoadAssociatedTuneupDef(entry);
    }
}

bool CacheSystem::IsPathContentDirRoot(const std::string& path) const
{
    // Helper for `LoadResource()` because OGRE's 'readOnly' flag, see explanation in `ContentManager::InitModCache()`
    // --------------------------------------------------------------------------------------------------------------

    for (const std::string& cdir: m_content_dirs)
    {
        if (path == PathCombine(App::sys_user_dir->getStr(), cdir))
        {
            return true;
        }
    }
    return false;
}

void CacheSystem::LoadResource(CacheEntryPtr& entry)
{
    if (!entry)
        return;

    // Check if already loaded for this entry->
    if (entry->resource_group != "")
    {
        this->LoadSupplementaryDocuments(entry);
        return;
    }

    Ogre::String group = CacheSystem::ComposeResourceGroupName(entry);

    // Make "FileSystem" (directory) bundles writable (Default is read-only), except if it's a root directory.
    // See explanation of `readOnly` OGRE flag in `ContentManager::InitModCache()`.
    bool readonly = entry->resource_bundle_type == "Zip" || this->IsPathContentDirRoot(entry->resource_bundle_path);
    bool recursive = false;

    // Load now.
    try
    {
        if (entry->fext == "terrn2")
        {
            // PagedGeometry is hardcoded to use `Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME`
            ResourceGroupManager::getSingleton().createResourceGroup(group, /*inGlobalPool=*/true);
            ResourceGroupManager::getSingleton().addResourceLocation(
                entry->resource_bundle_path, entry->resource_bundle_type, group, recursive, readonly);
        }
        else if (entry->fext == "skin")
        {
            // This is a SkinZip bundle - use `inGlobalPool=false` to prevent resource name conflicts.
            // Note: this code won't execute for .skin files in vehicle-bundles because in such case the bundle is already loaded by the vehicle's Cacheentry->
            ResourceGroupManager::getSingleton().createResourceGroup(group, /*inGlobalPool=*/false);
            ResourceGroupManager::getSingleton().addResourceLocation(
                entry->resource_bundle_path, entry->resource_bundle_type, group, recursive, readonly);
            App::GetContentManager()->InitManagedMaterials(group);
        }
        else if (entry->fext == "tuneup")
        {
            // This is a .tuneup bundle - use `inGlobalPool=false` to prevent resource name conflicts.
            ResourceGroupManager::getSingleton().createResourceGroup(group, /*inGlobalPool=*/false);
            ResourceGroupManager::getSingleton().addResourceLocation(
                entry->resource_bundle_path, entry->resource_bundle_type, group, recursive, readonly);
            App::GetContentManager()->InitManagedMaterials(group);
        }
        else
        {
            // A vehicle bundle - use `inGlobalPool=false` to prevent resource name conflicts.
            // See bottom 'note' at https://ogrecave.github.io/ogre/api/latest/_resource-_management.html#Resource-Groups
            ResourceGroupManager::getSingleton().createResourceGroup(group, /*inGlobalPool=*/false);
            ResourceGroupManager::getSingleton().addResourceLocation(
                entry->resource_bundle_path, entry->resource_bundle_type, group, recursive, readonly);

            App::GetContentManager()->InitManagedMaterials(group);
            App::GetContentManager()->AddResourcePack(ContentManager::ResourcePack::TEXTURES, group);
            App::GetContentManager()->AddResourcePack(ContentManager::ResourcePack::MATERIALS, group);
            App::GetContentManager()->AddResourcePack(ContentManager::ResourcePack::MESHES, group);
        }

        // Initialize resource group
        ResourceGroupManager::getSingleton().initialiseResourceGroup(group);
        entry->resource_group = group;

        this->LoadSupplementaryDocuments(entry);

        // Inform other entries sharing this bundle (i.e. '.skin' entries in vehicle bundles)
        for (CacheEntryPtr& i_entry: m_entries)
        {
            if (i_entry->resource_bundle_path == entry->resource_bundle_path)
            {
                i_entry->resource_group = group; // Mark as loaded
            }
        }
    }
    catch (Ogre::Exception& e)
    {
        RoR::LogFormat("[RoR] Error while loading '%s', message: %s",
            entry->resource_bundle_path.c_str(), e.getFullDescription().c_str());
        if (ResourceGroupManager::getSingleton().resourceGroupExists(group))
        {
            ResourceGroupManager::getSingleton().destroyResourceGroup(group);
        }
    }
}

void CacheSystem::ReLoadResource(CacheEntryPtr& entry)
{
    if (entry->resource_group == "")
    {
        return; // Not loaded - nothing to do
    }

    // IMPORTANT! No actors must use the bundle while reloading, use RoR::MsgType::MSG_EDI_RELOAD_BUNDLE_REQUESTED

    this->UnLoadResource(entry);
    this->LoadResource(entry); // Will create the same resource group again
}

void CacheSystem::UnLoadResource(CacheEntryPtr& entry)
{
    if (entry->resource_group == "")
    {
        return; // Not loaded - nothing to do
    }

    // IMPORTANT! No actors must use the bundle after reloading, use RoR::MsgType::MSG_EDI_RELOAD_BUNDLE_REQUESTED

    std::string resource_group = entry->resource_group; // Keep local copy, the CacheEntry will be blanked!
    for (CacheEntryPtr& i_entry: m_entries)
    {
        if (i_entry->resource_group == resource_group)
        {
            // Delete cached documents - force reload from disk
            i_entry->actor_def = nullptr;
            i_entry->tuneup_def = nullptr;
            i_entry->skin_def = nullptr;
            // Mark as unloaded
            i_entry->resource_group = "";
        }
    }

    Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup(resource_group);
}

CacheEntryPtr CacheSystem::FetchSkinByName(std::string const & skin_name)
{
    for (CacheEntryPtr & entry: m_entries)
    {
        if (entry->dname == skin_name && entry->fext == "skin")
        {
            return entry;
        }
    }
    return nullptr;
}

void CacheSystem::LoadAssociatedSkinDef(CacheEntryPtr& cache_entry)
{
    // A .skin file defines multiple skins, so we need to locate and update all associated cache entries.
    // --------------------------------------------------------------------------------------------------

    if (!cache_entry)
        return;
    
    ROR_ASSERT(cache_entry->resource_group != ""); // Must be already loaded

    if (cache_entry->skin_def != nullptr) // If already parsed, re-use
    {
        return;
    }

    try
    {
        Ogre::DataStreamPtr ds = Ogre::ResourceGroupManager::getSingleton()
            .openResource(cache_entry->fname, cache_entry->resource_group);

        auto new_skins = RoR::SkinParser::ParseSkins(ds); // Load the '.skin' file
        for (auto def: new_skins)
        {
            for (CacheEntryPtr& entry: m_entries)
            {
                if (entry->resource_bundle_path == cache_entry->resource_bundle_path
                    && entry->resource_bundle_type == cache_entry->resource_bundle_type
                    && entry->fname == cache_entry->fname
                    && entry->dname == def->name)
                {
                    entry->skin_def = def;
                    entry->resource_group = cache_entry->resource_group;
                }
            }
        }

        if (cache_entry->skin_def == nullptr)
        {
            RoR::LogFormat("Definition of skin '%s' was not found in file '%s'",
               cache_entry->dname.c_str(), cache_entry->fname.c_str());
        }
    }
    catch (Ogre::Exception& oex)
    {
        RoR::LogFormat("[RoR] Error loading skin file '%s', message: %s",
            cache_entry->fname.c_str(), oex.getFullDescription().c_str());
    }
}

void CacheSystem::LoadAssociatedTuneupDef(CacheEntryPtr& cache_entry)
{
    // A .tuneup file defines multiple tuneups, so we need to locate and update all associated cache entries.
    // --------------------------------------------------------------------------------------------------

    if (!cache_entry)
        return;
    
    ROR_ASSERT(cache_entry->resource_group != ""); // Must be already loaded

    if (cache_entry->tuneup_def != nullptr) // If already parsed, re-use
    {
        return;
    }

    try
    {
        Ogre::DataStreamPtr ds = Ogre::ResourceGroupManager::getSingleton()
            .openResource(cache_entry->fname, cache_entry->resource_group);

        auto new_tuneups = RoR::TuneupUtil::ParseTuneups(ds); // Load the '.tuneup' file
        for (auto def: new_tuneups)
        {
            for (CacheEntryPtr& entry: m_entries)
            {
                if (entry->resource_bundle_path == cache_entry->resource_bundle_path
                    && entry->resource_bundle_type == cache_entry->resource_bundle_type
                    && entry->fname == cache_entry->fname
                    && entry->dname == def->name)
                {
                    entry->tuneup_def = def;
                    entry->resource_group = cache_entry->resource_group;
                }
            }
        }

        if (cache_entry->tuneup_def == nullptr)
        {
            RoR::LogFormat("Definition of tuneup '%s' was not found in file '%s'",
               cache_entry->dname.c_str(), cache_entry->fname.c_str());
        }
    }
    catch (Ogre::Exception& oex)
    {
        RoR::LogFormat("[RoR] Error loading tuneup file '%s', message: %s",
            cache_entry->fname.c_str(), oex.getFullDescription().c_str());
    }
}

CacheEntryPtr CacheSystem::CreateProject(CreateProjectRequest* request)
{

    // Validate the request
    if (!request->cpr_source_entry)
    {
        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
            fmt::format(_LC("CacheSystem", "Cannot create project '{}' - no source mod specified!"), request->cpr_name));
        return nullptr;
    }

    // Make sure projects folder exists
    CreateFolder(App::sys_projects_dir->getStr());

    // Create subfolder
    std::string project_path = PathCombine(App::sys_projects_dir->getStr(), request->cpr_name);
    if (FolderExists(project_path) && !request->cpr_overwrite)
    {
        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
            fmt::format(_LC("CacheSystem", "Project directory '{}' already exists!"), request->cpr_name));
        return nullptr;
    }
    CreateFolder(project_path);
    if (!FolderExists(project_path))
    {
        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
            fmt::format(_LC("CacheSystem", "Project directory '{}' could not be created!"), request->cpr_name));
        return nullptr;
    }

    // Check if a project with the same name already exists
    CacheEntryPtr project_entry;
    bool project_entry_created = false;
    if (request->cpr_overwrite)
    {
        project_entry = this->FindEntryByFilename(LT_Tuneup, /*partial:*/false, fmt::format("{}.tuneup", request->cpr_name));
        this->LoadResource(project_entry); // This fills `entry.resource_group`
    }

    if (!project_entry)
    {
        // Create preliminary cache entry
        project_entry = new CacheEntry();
        project_entry_created = true;

        if (request->cpr_type == CreateProjectRequestType::SAVE_TUNEUP)
        {
            project_entry->fext = "tuneup"; // Tell modcache what it is.
            project_entry->categoryid = CID_Tuneups; // For display in modcache            
            project_entry->guid = request->cpr_source_entry->guid; // For lookup of tuneups by vehicle GUID.
                Ogre::StringUtil::toLowerCase(project_entry->guid);
                project_entry->tuneup_associated_filename = request->cpr_source_entry->fname; // For additional filtering of results (GUID marks a family, not individual mod).
                Ogre::StringUtil::toLowerCase(project_entry->tuneup_associated_filename);
        }
        else
        {
            project_entry->fext = request->cpr_source_entry->fext; // Tell modcache what it is.
            project_entry->categoryid = CID_Projects; // To list projects easily from cache
        }
        project_entry->categoryname = m_categories[project_entry->categoryid];
        project_entry->resource_bundle_type = "FileSystem"; // Tell modcache how to load it.
        project_entry->resource_bundle_path = project_path; // Tell modcache where to load it from.
        project_entry->fname = fmt::format("{}.{}", request->cpr_name, project_entry->fext); // Compose target mod filename
        project_entry->dname = request->cpr_name;
        project_entry->description = request->cpr_description;
        project_entry->number = static_cast<int>(m_entries.size() + 1); // Let's number mods from 1
        this->LoadResource(project_entry); // This fills `entry.resource_group`
    }
     
    if (request->cpr_type == CreateProjectRequestType::SAVE_TUNEUP)
    {
        // Tuneup projects don't contain any media, just the .tuneup file which lists addonparts to use.

        // Prepare the .tuneup document
        ROR_ASSERT(request->cpr_source_actor);
        ROR_ASSERT(request->cpr_source_actor->getWorkingTuneupDef());

        TuneupDefPtr tuneup = request->cpr_source_actor->getWorkingTuneupDef()->clone();
        tuneup->guid = request->cpr_source_entry->guid; // For lookup of tuneups by vehicle GUID.
            tuneup->filename = request->cpr_source_entry->fname; // For additional filtering of results (GUID marks a family, not individual mod).
        tuneup->name = request->cpr_name;
        tuneup->description = request->cpr_description;
        tuneup->thumbnail = request->cpr_source_entry->filecachename;
        tuneup->category_id = (CacheCategoryId)project_entry->categoryid;

        // Write out the .tuneup file.
        Ogre::DataStreamPtr datastream = Ogre::ResourceGroupManager::getSingleton().createResource(
            project_entry->fname, project_entry->resource_group, request->cpr_overwrite);
        TuneupUtil::ExportTuneup(datastream, tuneup);

        // Attach the document to the entry in memory
        project_entry->tuneup_def = tuneup;

        // In the likely case this was invoked from TopMenubarUI, update it.
        if (App::GetGuiManager()->TopMenubar.tuning_savebox_visible)
        {
            App::GetGuiManager()->TopMenubar.tuning_savebox_visible = false;
            App::GetGuiManager()->TopMenubar.tuning_actor = nullptr; // Force refresh
        }
    }
    else
    {

        // Create temporary resource group with only the data we want.
        std::string temp_rg = "TempProjectSourceRG";
        // Apart from `Resources` and resource groups, OGRE also keeps `Archives` in `ArchiveManager`
        // These aren't unloaded on destroying resource groups, and keep a 'readOnly' flag (defaults to true).
        // Upon loading/creating new resource groups, OGRE complains if the submitted flag doesn't match.
        // Since we want to make subdirs (with upacked mods) writable, we must purge subdir-archives now.
        bool readonly = request->cpr_source_entry->resource_bundle_type == "Zip";
        bool recursive = false;
        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
            request->cpr_source_entry->resource_bundle_path,
            request->cpr_source_entry->resource_bundle_type, temp_rg, recursive, readonly);
        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup(temp_rg);

        // Copy the files, one by one
        Ogre::FileInfoListPtr filelist = Ogre::ResourceGroupManager::getSingleton().findResourceFileInfo(temp_rg, "*.*");
        for (size_t i = 0; i < filelist->size(); i++)
        {
            Ogre::FileInfo fileinfo = filelist->at(i);

            // Render a frame with a progress window on it.
            App::GetGuiManager()->LoadingWindow.SetProgress(
                (i+1)/filelist->size(),
                fmt::format("Creating project from existing mod...\nCopying file {}/{} '{}'", i, filelist->size(), fileinfo.filename),
                /*render_frame:*/true);
            
            // Copy one file    
            try
            {
                DataStreamPtr src_ds = ResourceGroupManager::getSingleton().openResource(fileinfo.filename, temp_rg);
                DataStreamPtr dst_ds = ResourceGroupManager::getSingleton().createResource(fileinfo.filename, project_entry->resource_group);
                std::vector<char> buf(src_ds->size());
                size_t read = src_ds->read(buf.data(), src_ds->size());
                if (read > 0)
                {
                    dst_ds->write(buf.data(), read); 
                }
            }
            catch (Ogre::Exception& oex)
            {
                App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_WARNING,
                    fmt::format(_LC("CacheSystem", "Could not copy file '{}' to project '{}', message: {}."),
                        fileinfo.filename, request->cpr_name, oex.getDescription()));       
            }
        }

        App::GetGuiManager()->LoadingWindow.SetVisible(false);
        Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup(temp_rg);

        // Finally rename the mod file
        Ogre::FileSystemLayer::renameFile(
            /*oldPath:*/ PathCombine(project_path, request->cpr_source_entry->fname),
            /*newPath:*/ PathCombine(project_path, project_entry->fname));
    }


    if (project_entry_created)
    {
        // Add the new entry to database
        m_entries.push_back(project_entry);
    }

    // notify script
    modCacheActivityType activity_type = (project_entry_created) ? MODCACHEACTIVITY_ENTRY_ADDED : MODCACHEACTIVITY_ENTRY_MODIFIED;
    TRIGGER_EVENT_ASYNC(SE_GENERIC_MODCACHE_ACTIVITY,
        /*ints*/ activity_type, project_entry->number, 0, 0,
        /*strings*/ project_entry->fname, project_entry->fext);

    return project_entry;
}

void CacheSystem::ModifyProject(ModifyProjectRequest* request)
{
    ROR_ASSERT(request->mpr_target_actor);
    ROR_ASSERT(request->mpr_target_actor->ar_state != ActorState::DISPOSED);
    

    switch (request->mpr_type)
    {
    case ModifyProjectRequestType::TUNEUP_USE_ADDONPART_SET:
    {   
        request->mpr_target_actor->ensureWorkingTuneupDef();
        if (request->mpr_target_actor->getWorkingTuneupDef()->use_addonparts.count(request->mpr_subject) != 0)
        {
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_ACTOR, Console::CONSOLE_SYSTEM_WARNING,
                fmt::format(_LC("Tuning", "Addon part '{}' is already equipped."), request->mpr_subject));
            return; // Nothing to do!
        }
        
        CacheEntryPtr subject_entry = this->FindEntryByFilename(LT_AddonPart, /*partial=*/false, request->mpr_subject);
        if (!subject_entry)
        {
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_ACTOR, Console::CONSOLE_SYSTEM_WARNING,
                fmt::format(_LC("Tuning", "Addon part '{}' was not found in mod cache (probably not installed)."), request->mpr_subject));
            return; // Nothing to do!
        }

        if (AddonPartUtility::DoubleCheckForAddonpartConflict(request->mpr_target_actor, subject_entry))
        {
            return; // Error message box already shown
        }
        else
        {
            request->mpr_target_actor->getWorkingTuneupDef()->use_addonparts.insert(request->mpr_subject);
        }

        break;
    }

    case ModifyProjectRequestType::TUNEUP_USE_ADDONPART_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->use_addonparts.erase(request->mpr_subject);
        break;
    
    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_PROP_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_props.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_PROP_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_props.erase(request->mpr_subject_id);
        break;
    
    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLARE_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_flares.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLARE_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_flares.erase(request->mpr_subject_id);
        break;
    
    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLEXBODY_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_flexbodies.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLEXBODY_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_flexbodies.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCED_WHEEL_SIDE_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_wheel_sides[request->mpr_subject_id] = (WheelSide)request->mpr_value_int;
        break;

    case ModifyProjectRequestType::TUNEUP_FORCED_WHEEL_SIDE_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_wheel_sides.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_EXHAUST_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_exhausts.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_EXHAUST_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_exhausts.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_MANAGEDMAT_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_managedmats.insert(request->mpr_subject);
        break;

    case ModifyProjectRequestType::TUNEUP_FORCEREMOVE_MANAGEDMAT_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->force_remove_managedmats.erase(request->mpr_subject);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_PROP_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_props.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_PROP_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_props.erase(request->mpr_subject_id);
        break;
    
    case ModifyProjectRequestType::TUNEUP_PROTECTED_FLEXBODY_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_flexbodies.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_FLEXBODY_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_flexbodies.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_WHEEL_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_wheels.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_WHEEL_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_wheels.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_FLARE_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_flares.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_FLARE_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_flares.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_EXHAUST_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_exhausts.insert(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_EXHAUST_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_exhausts.erase(request->mpr_subject_id);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_MANAGEDMAT_SET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_managedmats.insert(request->mpr_subject);
        break;

    case ModifyProjectRequestType::TUNEUP_PROTECTED_MANAGEDMAT_RESET:
        request->mpr_target_actor->ensureWorkingTuneupDef();
        request->mpr_target_actor->getWorkingTuneupDef()->protected_managedmats.erase(request->mpr_subject);
        break;

    case ModifyProjectRequestType::PROJECT_LOAD_TUNEUP:
    {
        // Instead of loading with the saved tuneup directly, keep the autogenerated and sync it with the save.
        // That way, subsequent editing doesn't modify the save until user saves again.
        CacheEntryPtr save_entry = App::GetCacheSystem()->FindEntryByFilename(LT_Tuneup, /*partial:*/false, request->mpr_subject);
        if (!save_entry)
        {
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
                fmt::format(_LC("CacheSystem", "Error loading tuneup: file '{}', not found in mod cache"), request->mpr_subject));
            return;
        }
        this->LoadResource(save_entry);
        ROR_ASSERT(save_entry->tuneup_def);
        request->mpr_target_actor->getWorkingTuneupDef() = save_entry->tuneup_def->clone();
        ROR_ASSERT(request->mpr_target_actor->getWorkingTuneupDef());
        break;
    }

    case ModifyProjectRequestType::PROJECT_RESET_TUNEUP:
        request->mpr_target_actor->removeWorkingTuneupDef();
        ROR_ASSERT(!request->mpr_target_actor->getWorkingTuneupDef());
        break;

    default:
        break;
    }

    // Create spawn request while actor still exists
    // Note we don't use `ActorModifyRequest::Type::RELOAD` because we don't need the bundle reloaded.
    ActorSpawnRequest* srq = new ActorSpawnRequest;
    srq->asr_position     = Ogre::Vector3(request->mpr_target_actor->getPosition().x, request->mpr_target_actor->getMinHeight(), request->mpr_target_actor->getPosition().z);
    srq->asr_rotation     = Ogre::Quaternion(Ogre::Degree(270) - Ogre::Radian(request->mpr_target_actor->getRotation()), Ogre::Vector3::UNIT_Y);
    srq->asr_config       = request->mpr_target_actor->getSectionConfig();
    srq->asr_skin_entry   = request->mpr_target_actor->getUsedSkinEntry();
    srq->asr_working_tuneup = request->mpr_target_actor->getWorkingTuneupDef();
    srq->asr_cache_entry  = request->mpr_target_actor->getUsedActorEntry();
    srq->asr_debugview    = (int)request->mpr_target_actor->GetGfxActor()->GetDebugView();
    srq->asr_origin       = ActorSpawnRequest::Origin::USER;

    // Remove the actor
    App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, (void*)new ActorPtr(request->mpr_target_actor)));

    // Load our actor again, but only after it was deleted.
    App::GetGameContext()->ChainMessage(Message(MSG_SIM_SPAWN_ACTOR_REQUESTED, (void*)srq));
}

void CacheSystem::DeleteProject(CacheEntryPtr& entry)
{

        this->UnLoadResource(entry);

        // Delete the files, one by one
        const std::string DELETEPROJ_TEMP_RG = "DeleteProjectTempRG";
        Ogre::ResourceGroupManager::getSingleton().createResourceGroup(DELETEPROJ_TEMP_RG, /*inGlobalPool=*/false);
        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
            entry->resource_bundle_path, entry->resource_bundle_type, DELETEPROJ_TEMP_RG, /*recursive=*/false, /*readOnly=*/false);
        Ogre::FileInfoListPtr filelist = Ogre::ResourceGroupManager::getSingleton().findResourceFileInfo(DELETEPROJ_TEMP_RG, "*.*");
        LOG(fmt::format("[RoR|ModCache] Deleting project '{}' (resource group '{}'), found {} files to erase.", entry->fname, entry->resource_group, filelist->size()));
        for (size_t i = 0; i < filelist->size(); i++)
        {
            Ogre::FileInfo fileinfo = filelist->at(i);
            if (!Ogre::FileSystemLayer::removeFile(PathCombine(entry->resource_bundle_path, fileinfo.filename)))
            {
                App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
                    fmt::format(_LC("CacheSystem", "Problem deleting project '{}' - could not delete file '{}'"), entry->fname, fileinfo.filename));
            }
        }

        Ogre::ResourceGroupManager::getSingleton().destroyResourceGroup(DELETEPROJ_TEMP_RG);

        // Delete the directory itself
        if (!Ogre::FileSystemLayer::removeDirectory(entry->resource_bundle_path))
        {
            App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_ERROR,
                fmt::format(_LC("CacheSystem", "Problem deleting project '{}' - could not delete directory '{}'"), entry->fname, entry->resource_bundle_path));
        }

        // Remove the entry
        RoR::EraseIf(m_entries, [entry](CacheEntryPtr& e) { return e == entry; });

        // Force update of Tuning menu in TopMenubarUI.
        App::GetGuiManager()->TopMenubar.tuning_actor = nullptr;
}

size_t CacheSystem::Query(CacheQuery& query)
{
    Ogre::StringUtil::toLowerCase(query.cqy_search_string);
    Ogre::StringUtil::toLowerCase(query.cqy_filter_guid);
    Ogre::StringUtil::toLowerCase(query.cqy_filter_target_filename);
    std::time_t cur_time = std::time(nullptr);
    for (CacheEntryPtr& entry: m_entries)
    {
        // Filter by GUID
        if (query.cqy_filter_guid != "")
        {
            // Addon parts have `guid` empty
            if ((entry->fext == "addonpart" && entry->addonpart_guids.count(query.cqy_filter_guid) == 0) ||
                (entry->fext != "addonpart" && entry->guid != query.cqy_filter_guid))
            {
                continue;
            }
        }

        // Filter by target filename; pass items which have no target filenames listed.
        if (query.cqy_filter_target_filename != "")
        {
            if (entry->fext == "addonpart" 
                && entry->addonpart_filenames.size() > 0
                && entry->addonpart_filenames.count(query.cqy_filter_target_filename) == 0)
            {
                continue;
            }
            else if (entry->fext == "tuneup"
                && entry->tuneup_associated_filename != ""
                && entry->tuneup_associated_filename != query.cqy_filter_target_filename)
            {
                continue;
            }
        }

        // Filter by entry type
        bool add = false;
        if (entry->fext == "terrn2")
            add = (query.cqy_filter_type == LT_Terrain);
        if (entry->fext == "skin")
            add = (query.cqy_filter_type == LT_Skin);
        else if (entry->fext == "addonpart")
            add = (query.cqy_filter_type == LT_AddonPart);
        else if (entry->fext == "tuneup")
            add = (query.cqy_filter_type == LT_Tuneup);
        else if (entry->fext == "assetpack")
            add = (query.cqy_filter_type == LT_AssetPack);
        else if (entry->fext == "truck")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Vehicle || query.cqy_filter_type == LT_Truck);
        else if (entry->fext == "car")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Vehicle || query.cqy_filter_type == LT_Truck || query.cqy_filter_type == LT_Car);
        else if (entry->fext == "boat")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Boat);
        else if (entry->fext == "airplane")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Airplane);
        else if (entry->fext == "trailer")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Trailer || query.cqy_filter_type == LT_Extension);
        else if (entry->fext == "train")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Train);
        else if (entry->fext == "load")
            add = (query.cqy_filter_type == LT_AllBeam || query.cqy_filter_type == LT_Load || query.cqy_filter_type == LT_Extension);

        if (!add)
        {
            continue;
        }

        // Category usage stats
        query.cqy_res_category_usage[entry->categoryid]++;

        query.cqy_res_category_usage[CacheCategoryId::CID_All]++;

        const bool is_fresh = (cur_time - entry->addtimestamp) < CACHE_FILE_FRESHNESS;
        if (is_fresh)
            query.cqy_res_category_usage[CacheCategoryId::CID_Fresh]++;

        // Filter by category
        if ((query.cqy_filter_category_id <= CacheCategoryId::CID_Max && query.cqy_filter_category_id != entry->categoryid) ||
            (query.cqy_filter_category_id == CID_Fresh && !is_fresh))
        {
            continue;
        }

        // Search
        size_t score = 0;
        bool match = false;
        Str<100> wheels_str;
        switch (query.cqy_search_method)
        {
        case CacheSearchMethod::FULLTEXT:
            if (match = this->Match(score, entry->dname,       query.cqy_search_string, 0))   { break; }
            if (match = this->Match(score, entry->fname,       query.cqy_search_string, 100)) { break; }
            if (match = this->Match(score, entry->description, query.cqy_search_string, 200)) { break; }
            for (AuthorInfo const& author: entry->authors)
            {
                if (match = this->Match(score, author.name,  query.cqy_search_string, 300)) { break; }
                if (match = this->Match(score, author.email, query.cqy_search_string, 400)) { break; }
            }
            break;

        case CacheSearchMethod::GUID:
            match = this->Match(score, entry->guid, query.cqy_search_string, 0);
            break;

        case CacheSearchMethod::AUTHORS:
            for (AuthorInfo const& author: entry->authors)
            {
                if (match = this->Match(score, author.name,  query.cqy_search_string, 0)) { break; }
                if (match = this->Match(score, author.email, query.cqy_search_string, 0)) { break; }
            }
            break;

        case CacheSearchMethod::WHEELS:
            wheels_str << entry->wheelcount << "x" << entry->propwheelcount;
            match = this->Match(score, wheels_str.ToCStr(), query.cqy_search_string, 0);
            break;

        case CacheSearchMethod::FILENAME:
            match = this->Match(score, entry->fname, query.cqy_search_string, 100);
            break;

        default: // CacheSearchMethod::
            match = true;
            break;
        };

        if (match)
        {
            query.cqy_results.emplace_back(entry, score);
            query.cqy_res_last_update = std::max(query.cqy_res_last_update, entry->addtimestamp);
        }
    }

    std::sort(query.cqy_results.begin(), query.cqy_results.end());
    return query.cqy_results.size();
}

bool CacheSystem::Match(size_t& out_score, std::string data, std::string const& query, size_t score)
{
    Ogre::StringUtil::toLowerCase(data);
    size_t pos = data.find(query);
    if (pos != std::string::npos)
    {
        out_score = score + pos;
        return true;
    }
    else
    {
        return false;
    }
}

bool CacheQueryResult::operator<(CacheQueryResult const& other) const
{
    if (cqr_score == other.cqr_score)
    {
        Ogre::String first = this->cqr_entry->dname;
        Ogre::String second = other.cqr_entry->dname;
        Ogre::StringUtil::toLowerCase(first);
        Ogre::StringUtil::toLowerCase(second);
        return first < second;
    }

    return cqr_score < other.cqr_score;
}


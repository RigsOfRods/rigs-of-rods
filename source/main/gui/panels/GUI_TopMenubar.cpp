/*
    This source file is part of Rigs of Rods
    Copyright 2005-2012 Pierre-Michel Ricordel
    Copyright 2007-2012 Thomas Fischer
    Copyright 2016-2020 Petr Ohlidal

    For more information, see http://www.rigsofrods.org/

    Rigs of Rods is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 3, as
    published by the Free Software Foundation.

    Rigs of Rods is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Rigs of Rods. If not, see <http://www.gnu.org/licenses/>.
*/

/// @file
/// @author Petr Ohlidal
/// @date   06/2017

#include "GUI_TopMenubar.h"

#include "Application.h"
#include "Actor.h"
#include "ActorManager.h"
#include "CameraManager.h"
#include "DashBoardManager.h"
#include "FlexBody.h"
#include "GameContext.h"
#include "GfxScene.h"
#include "GUIManager.h"
#include "GUIUtils.h"
#include "GUI_MainSelector.h"
#include "InputEngine.h"
#include "Language.h"
#include "Network.h"
#include "PlatformUtils.h"
#include "Replay.h"
#include "SkyManager.h"
#include "Terrain.h"
#include "Terrn2FileFormat.h"
#include "TuneupFileFormat.h"
#include "GfxWater.h"
#include "ScriptEngine.h"
#include "Console.h"
#include "ContentManager.h"

#include <algorithm>
#include <fmt/format.h>


#ifdef USE_CURL
#   include <curl/curl.h>
#   include <curl/easy.h>
#endif //USE_CURL

#if defined(_MSC_VER) && defined(GetObject) // This MS Windows macro from <wingdi.h> (Windows Kit 8.1) clashes with RapidJSON
#   undef GetObject
#endif

using namespace RoR;
using namespace GUI;

#if defined(USE_CURL)

static size_t CurlWriteFunc(void *ptr, size_t size, size_t nmemb, std::string* data)
{
    data->append((char*)ptr, size * nmemb);
    return size * nmemb;
}

void FetchAiPresetsThreadFunc()
{
    // If local file 'savegames/waypoints.json' exists, load it; otherwise download from GitHub.
    // -----------------------------------------------------------------------------------------

    if (FileExists(PathCombine(App::sys_savegames_dir->getStr(), "waypoints.json")))
    {
        try
        {
            Ogre::DataStreamPtr stream = Ogre::ResourceGroupManager::getSingleton().openResource("waypoints.json", RGN_SAVEGAMES);
            Message m(MSG_NET_FETCH_AI_PRESETS_SUCCESS);
            m.description = stream->getAsString();
            App::GetGameContext()->PushMessage(m);
        }
        catch (...)
        {
            RoR::HandleGenericException("Top menubar / AI presets");
            Message m(MSG_NET_FETCH_AI_PRESETS_FAILURE);
            m.description = "Failed to load local AI presets.";
            App::GetGameContext()->PushMessage(m);
        }

        return; // DONE
    }

    std::string url = "https://raw.githubusercontent.com/RigsOfRods-Community/ai-waypoints/main/waypoints.json";
    std::string response_payload;
    long response_code = 0;

    CURL *curl = curl_easy_init();
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curl, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4);
#ifdef _WIN32
    curl_easy_setopt(curl, CURLOPT_SSL_OPTIONS, CURLSSLOPT_NATIVE_CA);
#endif // _WIN32
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, CurlWriteFunc);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_payload);

    CURLcode curl_result = curl_easy_perform(curl);
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);

    curl_easy_cleanup(curl);
    curl = nullptr;

    if (curl_result != CURLE_OK || response_code != 200)
    {
        Ogre::LogManager::getSingleton().stream()
            << "[RoR|Repository] Failed to download AI presets;"
            << " Error: '" << curl_easy_strerror(curl_result) << "'; HTTP status code: " << response_code;
        Message m(MSG_NET_FETCH_AI_PRESETS_FAILURE);
        m.description = "Failed to download AI presets.";
        App::GetGameContext()->PushMessage(m);
    }
    else
    {
        Message m(MSG_NET_FETCH_AI_PRESETS_SUCCESS);
        m.description = response_payload;
        App::GetGameContext()->PushMessage(m);
    }
}

#endif // defined(USE_CURL)

TopMenubar::TopMenubar()
{
    // Constructs `ActorPtr` - doesn't compile without `#include Actor.h` - not pretty if in header (even if auto-generated by C++).

    ai_presets_all.SetArray();
    ai_presets_bundled.SetArray();
    ai_presets_extern.SetArray();
}

TopMenubar::~TopMenubar()
{
    // Destructs `ActorPtr` - doesn't compile without `#include Actor.h` - not pretty if in header (even if auto-generated by C++).
}

void TopMenubar::Draw(float dt)
{
    // ## ImGui's 'menubar' and 'menuitem' features won't quite cut it...
    // ## Let's do our own menus and menuitems using buttons and coloring tricks.

    GUIManager::GuiTheme const& theme = App::GetGuiManager()->GetTheme();

    int num_playable_actors = 0;
    for (ActorPtr& actor: App::GetGameContext()->GetActorManager()->GetActors())
    {
        if (!actor->ar_hide_in_actor_list)
        {
            num_playable_actors++;
        }
    }

    std::string sim_title =         _LC("TopMenubar", "Simulation");
    std::string actors_title = fmt::format("{} ({})", _LC("TopMenubar", "Vehicles"), num_playable_actors);
    std::string savegames_title =   _LC("TopMenubar", "Saves");
    std::string settings_title =    _LC("TopMenubar", "Settings");
    std::string tools_title =       _LC("TopMenubar", "Tools");
    std::string ai_title =          _LC("TopMenubar", "Vehicle AI");
    std::string tuning_title =      _LC("TopMenubar", "Tuning");

    int menubar_num_buttons = 5;
    float menubar_content_width =
        ImGui::CalcTextSize(sim_title.c_str()).x +
        ImGui::CalcTextSize(actors_title.c_str()).x +
        ImGui::CalcTextSize(savegames_title.c_str()).x +
        ImGui::CalcTextSize(settings_title.c_str()).x +
        ImGui::CalcTextSize(tools_title.c_str()).x;

    if (this->IsMenuEnabled(TopMenu::TOPMENU_AI))
    {
        menubar_num_buttons += 1;
        menubar_content_width += ImGui::CalcTextSize(ai_title.c_str()).x;
    }

    if (this->IsMenuEnabled(TopMenu::TOPMENU_TUNING))
    {
        menubar_num_buttons += 1;
        menubar_content_width += ImGui::CalcTextSize(tuning_title.c_str()).x;
    }

    menubar_content_width +=
        (ImGui::GetStyle().ItemSpacing.x * (menubar_num_buttons - 1)) +
        (ImGui::GetStyle().FramePadding.x * (menubar_num_buttons * 2));

    ImVec2 window_target_pos = ImVec2((ImGui::GetIO().DisplaySize.x/2.f) - (menubar_content_width / 2.f), theme.screen_edge_padding.y);
    if (!this->ShouldDisplay(window_target_pos))
    {
        m_open_menu = TopMenu::TOPMENU_NONE;
        m_confirm_remove_all = false;
        this->DrawSpecialStateBox(10.f);
        return;
    }

    ImGui::PushStyleColor(ImGuiCol_WindowBg, theme.semitransparent_window_bg);
    ImGui::PushStyleColor(ImGuiCol_Button,   ImVec4(0,0,0,0)); // Fully transparent

    // The panel
    int flags = ImGuiWindowFlags_NoCollapse  | ImGuiWindowFlags_NoResize    | ImGuiWindowFlags_NoMove
              | ImGuiWindowFlags_NoTitleBar  | ImGuiWindowFlags_AlwaysAutoResize;
    ImGui::SetNextWindowContentSize(ImVec2(menubar_content_width, 0.f));
    ImGui::SetNextWindowPos(window_target_pos);
    ImGui::Begin("Top menubar", nullptr, flags);

    if (ImGui::IsWindowHovered())
    {
        ai_menu = false;
    }

    // The 'simulation' button
    ImVec2 window_pos = ImGui::GetWindowPos();
    ImVec2 sim_cursor = ImGui::GetCursorPos();
    ImGui::Button(sim_title.c_str());
    if ((m_open_menu != TopMenu::TOPMENU_SIM) && ImGui::IsItemHovered())
    {
        m_open_menu = TopMenu::TOPMENU_SIM;
    }

    // The 'Tuning' button - only shown if enabled
    ImVec2 tuning_cursor = ImVec2(0, 0);
    if (this->IsMenuEnabled(TopMenu::TOPMENU_TUNING))
    {
        ImGui::SameLine(); 
        tuning_cursor = ImGui::GetCursorPos();
        ImGui::Button(tuning_title.c_str());
        if ((m_open_menu != TopMenu::TOPMENU_TUNING) && ImGui::IsItemHovered())
        {
            m_open_menu = TopMenu::TOPMENU_TUNING;
        }
    } 

    // The 'AI' button - only shown in singleplayer
    ImVec2 ai_cursor = ImVec2(0, 0);
    if (this->IsMenuEnabled(TopMenu::TOPMENU_AI))
    {
        ImGui::SameLine();
        ai_cursor = ImGui::GetCursorPos();
        ImGui::Button(ai_title.c_str());
        if ((m_open_menu != TopMenu::TOPMENU_AI) && ImGui::IsItemHovered())
        {
            m_open_menu = TopMenu::TOPMENU_AI;
        }
    }

    ImGui::SameLine();

    // The 'vehicles' button
    ImVec2 actors_cursor = ImGui::GetCursorPos();
    ImGui::Button(actors_title.c_str());
    if ((m_open_menu != TopMenu::TOPMENU_ACTORS) && ImGui::IsItemHovered())
    {
        m_open_menu = TopMenu::TOPMENU_ACTORS;
    }

    ImGui::SameLine();

    // The 'savegames' button
    ImVec2 savegames_cursor = ImGui::GetCursorPos();
    ImGui::Button(savegames_title.c_str());
    if ((m_open_menu != TopMenu::TOPMENU_SAVEGAMES) && ImGui::IsItemHovered())
    {
        m_open_menu = TopMenu::TOPMENU_SAVEGAMES;
        m_quicksave_name = App::GetGameContext()->GetQuicksaveFilename();
        m_quickload = FileExists(PathCombine(App::sys_savegames_dir->getStr(), m_quicksave_name));
        m_savegame_names.clear();
        for (int i = 0; i <= 9; i++)
        {
            Ogre::String filename = Ogre::StringUtil::format("quicksave-%d.sav", i);
            m_savegame_names.push_back(App::GetGameContext()->ExtractSceneName(filename));
        }
    }

    ImGui::SameLine();

    // The 'settings' button
    ImVec2 settings_cursor = ImGui::GetCursorPos();
    ImGui::Button(settings_title.c_str());
    if ((m_open_menu != TopMenu::TOPMENU_SETTINGS) && ImGui::IsItemHovered())
    {
        m_open_menu = TopMenu::TOPMENU_SETTINGS;
#ifdef USE_CAELUM
        if (App::gfx_sky_mode->getEnum<GfxSkyMode>() == GfxSkyMode::CAELUM)
            m_daytime = App::GetGameContext()->GetTerrain()->getSkyManager()->GetTime();
#endif // USE_CAELUM
    }

    ImGui::SameLine();

    // The 'tools' button
    ImVec2 tools_cursor = ImGui::GetCursorPos();
    ImGui::Button(tools_title.c_str());
    if ((m_open_menu != TopMenu::TOPMENU_TOOLS) && ImGui::IsItemHovered())
    {
        m_open_menu = TopMenu::TOPMENU_TOOLS;
    }

    ImVec2 topmenu_final_size = ImGui::GetWindowSize();
    App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
    ImGui::End();

    this->DrawSpecialStateBox(window_target_pos.y + topmenu_final_size.y + 10.f);

    ImVec2 menu_pos;
    ActorPtr current_actor = App::GetGameContext()->GetPlayerActor();
    switch (m_open_menu)
    {
    case TopMenu::TOPMENU_SIM:
        menu_pos.y = window_pos.y + sim_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = sim_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Sim menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            // TODO: Display hotkeys on the right side of the menu (with different text color)

            if (ImGui::Button(_LC("TopMenubar", "Get new vehicle")))
            {
                m_open_menu = TopMenu::TOPMENU_NONE;

                RoR::Message m(MSG_GUI_OPEN_SELECTOR_REQUESTED);
                m.payload = reinterpret_cast<void*>(new LoaderType(LT_AllBeam));
                App::GetGameContext()->PushMessage(m);
            }

            if (current_actor != nullptr)
            {
                if (ImGui::Button(_LC("TopMenubar", "Show vehicle description")))
                {
                    App::GetGuiManager()->VehicleInfoTPanel.SetVisible(VehicleInfoTPanel::TPANELMODE_OPAQUE, VehicleInfoTPanel::TPANELFOCUS_COMMANDS);
                }

                if (current_actor->ar_state != ActorState::NETWORKED_OK)
                {
                    if (ImGui::Button(_LC("TopMenubar", "Reload current vehicle")))
                    {
                        ActorModifyRequest* rq = new ActorModifyRequest;
                        rq->amr_type = ActorModifyRequest::Type::RELOAD;
                        rq->amr_actor = current_actor->ar_instance_id;
                        App::GetGameContext()->PushMessage(Message(MSG_SIM_MODIFY_ACTOR_REQUESTED, (void*)rq));
                    }

                    if (ImGui::Button(_LC("TopMenubar", "Remove current vehicle")))
                    {
                        App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(current_actor))));
                    }
                }
            }
            else if (App::GetGameContext()->GetLastSpawnedActor())
            {
                if (ImGui::Button(_LC("TopMenubar", "Activate last spawned vehicle")))
                {
                    ActorModifyRequest* rq = new ActorModifyRequest;
                    rq->amr_type = ActorModifyRequest::Type::WAKE_UP;
                    rq->amr_actor = App::GetGameContext()->GetLastSpawnedActor()->ar_instance_id;
                    App::GetGameContext()->PushMessage(Message(MSG_SIM_MODIFY_ACTOR_REQUESTED, (void*)rq));
                }

                if (ImGui::Button(_LC("TopMenubar", "Reload last spawned vehicle")))
                {
                    ActorModifyRequest* rq = new ActorModifyRequest;
                    rq->amr_type = ActorModifyRequest::Type::RELOAD;
                    rq->amr_actor = App::GetGameContext()->GetLastSpawnedActor()->ar_instance_id;
                    App::GetGameContext()->PushMessage(Message(MSG_SIM_MODIFY_ACTOR_REQUESTED, (void*)rq));
                }

                if (ImGui::Button(_LC("TopMenubar", "Remove last spawned vehicle")))
                {
                    ActorPtr actor = App::GetGameContext()->GetLastSpawnedActor();
                    App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                }
            }

            if (!App::GetGameContext()->GetActorManager()->GetLocalActors().empty())
            {
                if (ImGui::Button(_LC("TopMenubar", "Remove all vehicles")))
                {
                    m_confirm_remove_all = true;
                }
                if (m_confirm_remove_all)
                {
                    ImGui::PushStyleColor(ImGuiCol_Text, ORANGE_TEXT);
                    if (ImGui::Button(_LC("TopMenubar", " [!] Confirm removal")))
                    {
                        for (ActorPtr& actor : App::GetGameContext()->GetActorManager()->GetLocalActors())
                        {
                            if (!actor->ar_hide_in_actor_list && !actor->isPreloadedWithTerrain() && 
                                    actor->ar_state != ActorState::NETWORKED_OK)
                            {
                                App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                            }
                        }
                        m_confirm_remove_all = false;
                    }
                    ImGui::PopStyleColor();
                }

                if (ImGui::Button(_LC("TopMenubar", "Activate all vehicles")))
                {
                    App::GetGameContext()->GetActorManager()->WakeUpAllActors();
                }

                bool force_trucks_active = App::GetGameContext()->GetActorManager()->AreTrucksForcedAwake();
                if (ImGui::Checkbox(_LC("TopMenubar", "Activated vehicles never sleep"), &force_trucks_active))
                {
                    App::GetGameContext()->GetActorManager()->SetTrucksForcedAwake(force_trucks_active);
                }

                if (ImGui::Button(_LC("TopMenubar", "Send all vehicles to sleep")))
                {
                    App::GetGameContext()->GetActorManager()->SendAllActorsSleeping();
                }
            }

            if (App::mp_state->getEnum<MpState>() != MpState::CONNECTED)
            {
                if (ImGui::Button(_LC("TopMenubar", "Reload current terrain")))
                {
                    App::GetGameContext()->PushMessage(Message(MsgType::MSG_SIM_UNLOAD_TERRN_REQUESTED));
                    // Order is required - create chain.
                    App::GetGameContext()->ChainMessage(Message(MsgType::MSG_EDI_RELOAD_BUNDLE_REQUESTED,
                        new CacheEntryPtr(App::GetGameContext()->GetTerrain()->getCacheEntry())));
                    App::GetGameContext()->ChainMessage(Message(MsgType::MSG_SIM_LOAD_TERRN_REQUESTED,
                        App::GetGameContext()->GetTerrain()->getCacheEntry()->fname));
                }

                if (App::sim_state->getEnum<SimState>() == SimState::EDITOR_MODE
                    && App::GetGameContext()->GetTerrain()->getCacheEntry()->resource_bundle_type == "FileSystem"
                    && ImGui::Button(_LC("TopMenubar", "Save changes to terrain")))
                {
                    // This is a project (unzipped mod) - update TOBJ files in place
                    App::GetGameContext()->PushMessage(Message(MsgType::MSG_EDI_SAVE_TERRN_CHANGES_REQUESTED));
                }
            }

            ImGui::Separator();

            if (ImGui::Button(_LC("TopMenubar", "Back to menu")))
            {
                if (App::mp_state->getEnum<MpState>() == MpState::CONNECTED)
                {
                    App::GetGameContext()->PushMessage(Message(MSG_NET_DISCONNECT_REQUESTED));
                }
                App::GetGameContext()->PushMessage(Message(MSG_SIM_UNLOAD_TERRN_REQUESTED));
                App::GetGameContext()->PushMessage(Message(MSG_GUI_OPEN_MENU_REQUESTED));
            }

            if (ImGui::Button(_LC("TopMenubar", "Exit")))
            {
                App::GetGameContext()->PushMessage(Message(MSG_APP_SHUTDOWN_REQUESTED));
            }

            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_ACTORS:
        menu_pos.y = window_pos.y + actors_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = actors_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Actors menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            if (App::mp_state->getEnum<MpState>() != MpState::CONNECTED)
            {
                this->DrawActorListSinglePlayer();
            }
            else
            {
#ifdef USE_SOCKETW
                RoRnet::UserInfo net_user_info = App::GetNetwork()->GetLocalUserData();
                this->DrawMpUserToActorList(net_user_info);

                std::vector<RoRnet::UserInfo> remote_users = App::GetNetwork()->GetUserInfos();
                for (auto& user: remote_users)
                {
                    this->DrawMpUserToActorList(user);
                }
#endif // USE_SOCKETW
            }
            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_SAVEGAMES:
        menu_pos.y = window_pos.y + savegames_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = savegames_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Savegames"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            if (ImGui::Button(_LC("TopMenubar", "Quicksave")))
            {
                App::GetGameContext()->GetActorManager()->SaveScene(m_quicksave_name);
                m_open_menu = TopMenu::TOPMENU_NONE;
            }
            ImGui::SameLine();
            ImGui::TextColored(GRAY_HINT_TEXT, "(NUMPAD: /)");

            if (m_quickload)
            {
                if (ImGui::Button(_LC("TopMenubar", "Quickload")))
                {
                    App::GetGameContext()->GetActorManager()->LoadScene(m_quicksave_name);
                    m_open_menu = TopMenu::TOPMENU_NONE;
                }
                ImGui::SameLine();
                ImGui::TextColored(GRAY_HINT_TEXT, "(NUMPAD: *)");
            }

            ImGui::Separator();

            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "(Save with CTRL+ALT+1..5)"));
            for (int i = 1; i <= 5; i++)
            {
                Ogre::String name = _LC("TopMenubar", "Empty Slot");
                if (!m_savegame_names[i].empty())
                {
                    name = m_savegame_names[i];
                }
                Ogre::String caption = Ogre::StringUtil::format("%d. %s##Save", i, name.c_str());
                if (ImGui::Button(caption.c_str()))
                {
                    Ogre::String filename = Ogre::StringUtil::format("quicksave-%d.sav", i);
                    App::GetGameContext()->GetActorManager()->SaveScene(filename);
                    m_open_menu = TopMenu::TOPMENU_NONE;
                }
            }

            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "(Load with ALT+1..5)"));
            for (int i = 1; i <= 5; i++)
            {
                if (!m_savegame_names[i].empty())
                {
                    Ogre::String name = m_savegame_names[i];
                    Ogre::String caption = Ogre::StringUtil::format("%d. %s##Load", i, name.c_str());
                    if (ImGui::Button(caption.c_str()))
                    {
                        Ogre::String filename = Ogre::StringUtil::format("quicksave-%d.sav", i);
                        App::GetGameContext()->PushMessage(RoR::Message(MSG_SIM_LOAD_SAVEGAME_REQUESTED, filename));
                        m_open_menu = TopMenu::TOPMENU_NONE;
                    }
                }
            }

            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_SETTINGS:
        menu_pos.y = window_pos.y + settings_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = settings_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Settings menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            // AUDIO SETTINGS
            ImGui::Separator();
            ImGui::PushItemWidth(125.f); // Width includes [+/-] buttons
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar",  "Audio:"));
            DrawGFloatSlider(App::audio_master_volume, _LC("TopMenubar", "Volume"), 0, 1);

            // RENDER SETTINGS
            ImGui::Separator();
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Frames per second:"));
            if (App::gfx_envmap_enabled->getBool())
            {
                DrawGIntSlider(App::gfx_envmap_rate, _LC("TopMenubar", "Reflections"), 0, 2);
            }
            DrawGIntSlider(App::gfx_fps_limit, _LC("TopMenubar", "Game"), 0, 240);

            // SIM SETTINGS
            ImGui::Separator();
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Simulation:"));
            float slowmotion = std::min(App::GetGameContext()->GetActorManager()->GetSimulationSpeed(), 1.0f);
            if (ImGui::SliderFloat(_LC("TopMenubar", "Slow motion"), &slowmotion, 0.01f, 1.0f))
            {
                App::GetGameContext()->GetActorManager()->SetSimulationSpeed(slowmotion);
            }
            float timelapse = std::max(App::GetGameContext()->GetActorManager()->GetSimulationSpeed(), 1.0f);
            if (ImGui::SliderFloat(_LC("TopMenubar", "Time lapse"), &timelapse, 1.0f, 10.0f))
            {
                App::GetGameContext()->GetActorManager()->SetSimulationSpeed(timelapse);
            }

            // CAMERA SETTINGS
            if (App::GetCameraManager()->GetCurrentBehavior() == CameraManager::CAMERA_BEHAVIOR_STATIC)
            {
                ImGui::Separator();
                ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Camera:"));
                DrawGFloatSlider(App::gfx_static_cam_fov_exp, _LC("TopMenubar", "FOV"), 0.8f, 1.5f);
                DrawGIntSlider(App::gfx_camera_height, _LC("TopMenubar", "Height"), 1, 50);
            }
            else
            {
                ImGui::Separator();
                ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Camera:"));
                if (App::GetCameraManager()->GetCurrentBehavior() == CameraManager::CAMERA_BEHAVIOR_VEHICLE_CINECAM)
                {
                    int fov = App::gfx_fov_internal->getInt();
                    if (ImGui::SliderInt(_LC("TopMenubar", "FOV"), &fov, 10, 120))
                    {
                        App::gfx_fov_internal->setVal(fov);
                    }
                }
                else
                {
                    int fov = App::gfx_fov_external->getInt();
                    if (ImGui::SliderInt(_LC("TopMenubar", "FOV"), &fov, 10, 120))
                    {
                        App::gfx_fov_external->setVal(fov);
                    }
                }
                if (App::GetCameraManager()->GetCurrentBehavior() == CameraManager::CAMERA_BEHAVIOR_FIXED)
                {
                    DrawGCheckbox(App::gfx_fixed_cam_tracking, _LC("TopMenubar", "Tracking"));
                }
            }

            // SKY SETTINGS
#ifdef USE_CAELUM
            if (App::gfx_sky_mode->getEnum<GfxSkyMode>() == GfxSkyMode::CAELUM)
            {
                ImGui::Separator();
                ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Time of day:"));
                float time = App::GetGameContext()->GetTerrain()->getSkyManager()->GetTime();
                if (ImGui::SliderFloat("", &time, m_daytime - 0.5f, m_daytime + 0.5f, ""))
                {
                    App::GetGameContext()->GetTerrain()->getSkyManager()->SetTime(time);
                }
                ImGui::SameLine();
                DrawGCheckbox(App::gfx_sky_time_cycle, _LC("TopMenubar", "Cycle"));
                if (App::gfx_sky_time_cycle->getBool())
                {
                    DrawGIntSlider(App::gfx_sky_time_speed, _LC("TopMenubar", "Speed"), 10, 2000);
                }
            }       
#endif // USE_CAELUM

            // WATER SETTINGS
            if (RoR::App::gfx_water_waves->getBool() && App::mp_state->getEnum<MpState>() != MpState::CONNECTED && App::GetGameContext()->GetTerrain()->getWater())
            {
                if (App::gfx_water_mode->getEnum<GfxWaterMode>() != GfxWaterMode::HYDRAX && App::gfx_water_mode->getEnum<GfxWaterMode>() != GfxWaterMode::NONE)
                {
                    ImGui::PushID("waves");
                    ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Waves Height:"));
                    if(ImGui::SliderFloat("", &m_waves_height, 0.f, 4.f, ""))
                    {
                        App::GetGameContext()->GetTerrain()->getWater()->SetWavesHeight(m_waves_height);
                    }
                    ImGui::PopID();
                }
            }    
            
            // VEHICLE CONTROL SETTINGS
            if (current_actor != nullptr)
            {
                ImGui::Separator();
                ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar",  "Vehicle control options:"));
                DrawGCheckbox(App::io_hydro_coupling, _LC("TopMenubar", "Keyboard steering speed coupling"));
            }

            // MULTIPLAYER SETTINGS
            if (App::mp_state->getEnum<MpState>() == MpState::CONNECTED)
            {
                ImGui::Separator();
                ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Multiplayer:"));
                DrawGCheckbox(App::mp_pseudo_collisions, _LC("TopMenubar", "Collisions"));
                DrawGCheckbox(App::mp_hide_net_labels,   _LC("TopMenubar", "Hide labels"));
            }
            ImGui::PopItemWidth();
            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_TOOLS:
        menu_pos.y = window_pos.y + tools_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = tools_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Tools menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            if (ImGui::Button(_LC("TopMenubar", "Friction settings")))
            {
                App::GetGuiManager()->FrictionSettings.SetVisible(true);
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            if (ImGui::Button(_LC("TopMenubar", "Show console")))
            {
                App::GetGuiManager()->ConsoleWindow.SetVisible(!App::GetGuiManager()->ConsoleWindow.IsVisible());
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            if (ImGui::Button(_LC("TopMenubar", "Texture tool")))
            {
                App::GetGuiManager()->TextureToolWindow.SetVisible(true);
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            if (ImGui::Button(_LC("TopMenubar", "Collisions debug")))
            {
                App::GetGuiManager()->CollisionsDebug.SetVisible(true);
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            if (current_actor != nullptr)
            {
                if (ImGui::Button(_LC("TopMenubar", "Node / Beam utility")))
                {
                    App::GetGuiManager()->NodeBeamUtils.SetVisible(true);
                    m_open_menu = TopMenu::TOPMENU_NONE;
                }

                if (ImGui::Button(_LC("TopMenubar", "FlexBody debug")))
                {
                    App::GetGuiManager()->FlexbodyDebug.SetVisible(true);
                    m_open_menu = TopMenu::TOPMENU_NONE;
                }
            }

            if (ImGui::Button(_LC("TopMenubar", "Browse gadgets ...")))
            {
                App::GetGameContext()->PushMessage(Message(MSG_GUI_OPEN_SELECTOR_REQUESTED, new LoaderType(LT_Gadget)));
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            if (ImGui::Button(_LC("TopMenubar", "Browse repository ...")))
            {
                App::GetGuiManager()->RepositorySelector.SetVisible(true);
                m_open_menu = TopMenu::TOPMENU_NONE;
            }

            ImGui::Separator();
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Pre-spawn diag. options:"));

            bool diag_mass = App::diag_truck_mass->getBool();
            if (ImGui::Checkbox(_LC("TopMenubar", "Node mass recalc. logging"), &diag_mass))
            {
                App::diag_truck_mass->setVal(diag_mass);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Extra logging on runtime - mass recalculation"));
                ImGui::EndTooltip();
            }

            bool diag_break = App::diag_log_beam_break->getBool();
            if (ImGui::Checkbox(_LC("TopMenubar", "Beam break logging"), &diag_break))
            {
                App::diag_log_beam_break->setVal(diag_break);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Extra logging on runtime"));
                ImGui::EndTooltip();
            }

            bool diag_deform = App::diag_log_beam_deform->getBool();
            if (ImGui::Checkbox(_LC("TopMenubar", "Beam deform. logging"), &diag_deform))
            {
                App::diag_log_beam_deform->setVal(diag_deform);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Extra logging on runtime"));
                ImGui::EndTooltip();
            }

            bool diag_trig = App::diag_log_beam_trigger->getBool();
            if (ImGui::Checkbox(_LC("TopMenubar", "Trigger logging"), &diag_trig))
            {
                App::diag_log_beam_trigger->setVal(diag_trig);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Extra logging on runtime - trigger beams activity"));
                ImGui::EndTooltip();
            }

            bool diag_vcam = App::diag_videocameras->getBool();
            if (ImGui::Checkbox(_LC("TopMenubar", "VideoCamera direction marker"), &diag_vcam))
            {
                App::diag_videocameras->setVal(diag_vcam);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Visual marker of VideoCameras direction"));
                ImGui::EndTooltip();
            }

            ImGui::PushItemWidth(125.f); // Width includes [+/-] buttons
            ImGui::Separator();
            ImGui::TextColored(GRAY_HINT_TEXT, _LC("TopMenubar", "Visual options:"));
            DrawGIntSlider(App::gfx_polygon_mode, _LC("TopMenubar", "Polygon mode"), 1, 3);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "1 = Solid"));
                ImGui::Text("%s", _LC("TopMenubar", "2 = Wireframe"));
                ImGui::Text("%s", _LC("TopMenubar", "3 = Points"));
                ImGui::EndTooltip();
            }

            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_AI:
        menu_pos.y = window_pos.y + ai_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = ai_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "AI menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            if (ImGui::IsWindowHovered())
            {
                ai_menu = false;
            }

            ImGui::PushItemWidth(125.f); // Width includes [+/-] buttons
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "General options:"));

            if (ai_num < 1)
                ai_num = 1;


            if (ai_mode == 2 || ai_mode == 3) // Drag Race or Crash driving mode
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            ImGui::InputInt(_LC("TopMenubar", "Vehicle count"), &ai_num, 1, 100);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Number of vehicles"));
                ImGui::EndTooltip();
            }

            if (ai_mode == 2 || ai_mode == 3) // Drag Race or Crash driving mode
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            if (ai_num < 2)
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            if (ai_mode == 3) // Crash driving mode
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            ImGui::InputInt(_LC("TopMenubar", "Distance"), &ai_distance, 1, 100);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Following distance in meters"));
                ImGui::EndTooltip();
            }

            if (ai_mode == 3) // Crash driving mode
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            std::string label1 = "Behind";
            if (ai_position_scheme == 1)
            {
                label1 = "Parallel";
            }
            else if (ai_position_scheme == 2)
            {
                label1 = "Opposite";
            }

            if (ai_mode == 2 || ai_mode == 3) // Drag Race or Crash driving mode
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            if (ImGui::BeginCombo("Position", label1.c_str()))
            {
                if (ImGui::Selectable("Behind"))
                {
                    ai_position_scheme = 0;
                }
                if (ImGui::Selectable("Parallel"))
                {
                    ai_position_scheme = 1;
                }
                ImGui::EndCombo();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Positioning scheme"));
                ImGui::Separator();
                ImGui::Text("%s", _LC("TopMenubar", "Behind: Set vehicle behind vehicle, in line"));
                ImGui::Text("%s", _LC("TopMenubar", "Parallel: Set vehicles in parallel, useful for certain scenarios like drag races"));
                ImGui::EndTooltip();
            }

            if (ai_num < 2)
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            if (ai_times < 1)
                ai_times = 1;

            if (ai_mode == 4) // Chase driving mode
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            ImGui::InputInt(_LC("TopMenubar", "Repeat times"), &ai_times, 1, 100);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "How many times to loop the path"));
                ImGui::EndTooltip();
            }

            if (ai_mode == 4) // Chase driving mode
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            if (ai_mode == 2 || ai_mode == 3) // Drag Race or Crash driving mode
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            ImGui::Separator();
            ImGui::TextColored(GRAY_HINT_TEXT, "%s", _LC("TopMenubar", "Vehicle options:"));

            std::string label2 = "Normal";
            if (ai_mode == 1)
            {
                label2 = "Race";
            }
            else if (ai_mode == 2)
            {
                label2 = "Drag Race";
            }
            else if (ai_mode == 3)
            {
                label2 = "Crash";
            }
            else if (ai_mode == 4)
            {
                label2 = "Chase";
            }

            for (auto actor : App::GetGameContext()->GetActorManager()->GetLocalActors())
            {
                if (actor->ar_driveable == AI)
                {
                    ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
                    break;
                }
            }

            if (ImGui::BeginCombo("Mode", label2.c_str()))
            {
                if (ImGui::Selectable("Normal"))
                {
                    ai_mode = 0;

                    if (ai_mode_prev == 2 || ai_mode_prev == 3)
                    {
                        ai_num = ai_num_prev;
                        ai_speed = ai_speed_prev;
                        ai_position_scheme = ai_position_scheme_prev;
                        ai_times = ai_times_prev;
                    }
                    ai_mode_prev = ai_mode;
                }
                if (ImGui::Selectable("Race"))
                {
                    ai_mode = 1;

                    if (ai_mode_prev == 2 || ai_mode_prev == 3)
                    {
                        ai_num = ai_num_prev;
                        ai_speed = ai_speed_prev;
                        ai_position_scheme = ai_position_scheme_prev;
                        ai_times = ai_times_prev;
                    }
                    ai_mode_prev = ai_mode;
                }
                if (ImGui::Selectable("Drag Race"))
                {
                    ai_mode = 2;

                    if (ai_mode_prev != 3)
                    {
                        ai_num_prev = ai_num;
                        ai_speed_prev = ai_speed;
                        ai_position_scheme_prev = ai_position_scheme;
                        ai_times_prev = ai_times;
                    }
                    ai_mode_prev = ai_mode;
                    ai_num = 2;
                    ai_speed = 1000;
                    ai_position_scheme = 1;
                    ai_times = 1;
                }
                if (ImGui::Selectable("Crash"))
                {
                    ai_mode = 3;
                    if (ai_mode_prev != 2)
                    {
                        ai_num_prev = ai_num;
                        ai_speed_prev = ai_speed;
                        ai_position_scheme_prev = ai_position_scheme;
                        ai_times_prev = ai_times;
                    }
                    ai_mode_prev = ai_mode;
                    ai_num = 2;
                    ai_speed = 100;
                    ai_position_scheme = 2;
                    ai_times = 1;
                }
                if (ImGui::Selectable("Chase"))
                {
                    ai_mode = 4;

                    if (ai_mode_prev == 2 || ai_mode_prev == 3)
                    {
                        ai_num = ai_num_prev;
                        ai_speed = ai_speed_prev;
                        ai_position_scheme = ai_position_scheme_prev;
                        ai_times = ai_times_prev;
                    }
                    ai_mode_prev = ai_mode;
                }
                ImGui::EndCombo();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Land vehicle driving mode"));
                ImGui::Separator();
                ImGui::Text("%s", _LC("TopMenubar", "Normal: Modify speed according to turns, other vehicles and character"));
                ImGui::Text("%s", _LC("TopMenubar", "Race: Always keep defined speed"));
                ImGui::Text("%s", _LC("TopMenubar", "Drag Race: Two vehicles performing a drag race"));
                ImGui::Text("%s", _LC("TopMenubar", "Crash: Two vehicles driving in opposite direction"));
                ImGui::Text("%s", _LC("TopMenubar", "Chase: Follow character and player vehicle"));
                ImGui::EndTooltip();
            }

            for (auto actor : App::GetGameContext()->GetActorManager()->GetLocalActors())
            {
                if (actor->ar_driveable == AI)
                {
                    ImGui::PopItemFlag();
                    ImGui::PopStyleVar();
                    break;
                }
            }

            if (ai_speed < 1)
                ai_speed = 1;

            ImGui::InputInt(_LC("TopMenubar", "Speed"), &ai_speed, 1, 100);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Speed in km/h for land vehicles or knots/s for boats"));
                ImGui::EndTooltip();
            }

            if (ai_altitude < 1)
                ai_altitude = 1;

            ImGui::InputInt(_LC("TopMenubar", "Altitude"), &ai_altitude, 1, 100);
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Airplane maximum altitude in feet"));
                ImGui::EndTooltip();
            }

            ImGui::Separator();

            if (ImGui::Button(StripColorMarksFromText(ai_dname).c_str(), ImVec2(250, 0)))
            {
                ai_select = true;

                RoR::Message m(MSG_GUI_OPEN_SELECTOR_REQUESTED);
                m.payload = reinterpret_cast<void*>(new LoaderType(LT_AllBeam));
                App::GetGameContext()->PushMessage(m);
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%s", _LC("TopMenubar", "Land vehicles, boats and airplanes"));
                ImGui::EndTooltip();
            }

            if (ai_mode == 2 || ai_mode == 3) // Drag Race or Crash driving mode
            {
                ImGui::PushID("vehicle2");
                if (ImGui::Button(StripColorMarksFromText(ai_dname2).c_str(), ImVec2(250, 0)))
                {
                    ai_select2 = true;

                    RoR::Message m(MSG_GUI_OPEN_SELECTOR_REQUESTED);
                    m.payload = reinterpret_cast<void*>(new LoaderType(LT_AllBeam));
                    App::GetGameContext()->PushMessage(m);
                }
                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("%s", _LC("TopMenubar", "Land vehicles, boats and airplanes"));
                    ImGui::EndTooltip();
                }
                ImGui::PopID();
            }

            ImGui::Separator();

            if (ai_rec)
            {
                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
            }

            if (!ai_waypoints.empty() || ai_mode == 4) // Waypoints provided or Chase driving mode
            {
                ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_ButtonActive]);
            }

            if (ImGui::Button(_LC("TopMenubar", "Start"), ImVec2(80, 0)))
            {
                if (ai_mode == 4) // Chase driving mode
                {
                    ai_waypoints.clear();
                    if (App::GetGameContext()->GetPlayerActor()) // We are in vehicle
                    {
                        ai_events waypoint;
                        waypoint.position = App::GetGameContext()->GetPlayerActor()->getPosition() + Ogre::Vector3(20, 0, 0);
                        ai_waypoints.push_back(waypoint);
                    }
                    else // We are in feet
                    {
                        ai_events waypoint;
                        waypoint.position = App::GetGameContext()->GetPlayerCharacter()->getPosition() + Ogre::Vector3(20, 0, 0);
                        ai_waypoints.push_back(waypoint);
                    }
                    App::GetScriptEngine()->loadScript("AI.as", ScriptCategory::CUSTOM);
                }
                else
                {
                    if (ai_waypoints.empty())
                    {
                        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_NOTICE,
                                                      fmt::format(_LC("TopMenubar", "Select a preset, record or open survey map ({}) to set waypoints."),
                                                      App::GetInputEngine()->getEventCommandTrimmed(EV_SURVEY_MAP_CYCLE)), "lightbulb.png");
                    }
                    else
                    {
                        App::GetScriptEngine()->loadScript("AI.as", ScriptCategory::CUSTOM);
                    }
                }
            }

            if (!ai_waypoints.empty() || ai_mode == 4) // Waypoints provided or Chase driving mode
            {
                ImGui::PopStyleColor();
            }

            ImGui::SameLine();

            if (ImGui::Button(_LC("TopMenubar", "Stop"), ImVec2(80, 0)))
            {
                if (ai_mode == 4) // Chase driving mode
                {
                    ai_waypoints.clear();
                }

                for (ActorPtr& actor : App::GetGameContext()->GetActorManager()->GetLocalActors())
                {
                    if (actor->ar_driveable == AI)
                    {
                        App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                    }
                }
            }

            if (ai_rec)
            {
                ImGui::PopItemFlag();
                ImGui::PopStyleVar();
            }

            ImGui::SameLine();

            ImGui::PushStyleColor(ImGuiCol_Button, ImGui::GetStyle().Colors[ImGuiCol_Button]);
            std::string label = "Record";
            if (ai_rec)
            {
                label = "Recording";
                ImGui::PushStyleColor(ImGuiCol_Button, RED_TEXT);
            }

            if (ImGui::Button(label.c_str(), ImVec2(80, 0)))
            {
                if (!ai_rec)
                {
                    ai_waypoints.clear();
                    ai_rec = true;
                }
                else
                {
                   ai_rec = false;
                }
            }

            ImGui::PopStyleColor();
            ImGui::Separator();

            if (ImGui::CollapsingHeader(_LC("TopMenubar", "Presets")))
            {
                // Draw whatever we already have (i.e. presets bundled with terrain, see '[AI Presets]' in terrn2 format).
                size_t num_rows = ai_presets_all.GetArray().Size();
                int display_count = 0;
                for (size_t i = 0; i < num_rows; i++)
                {
                    rapidjson::Value& j_row = ai_presets_all[static_cast<rapidjson::SizeType>(i)];

                    if (j_row.HasMember("terrain") && App::sim_terrain_name->getStr() == j_row["terrain"].GetString())
                    {
                        display_count++;
                        if (ImGui::Button(j_row["preset"].GetString(), ImVec2(250, 0)))
                        {
                            ai_waypoints.clear();

                            for (size_t i = 0; i < j_row["waypoints"].Size(); i++)
                            {
                                float x = j_row["waypoints"][i][0].GetFloat();
                                float y = j_row["waypoints"][i][1].GetFloat();
                                float z = j_row["waypoints"][i][2].GetFloat();

                                ai_events waypoint;
                                waypoint.position = Ogre::Vector3(x, y, z);

                                int speed = -1;
                                if (j_row["waypoints"][i].Size() == 4) // Custom speed defined
                                {
                                    speed = j_row["waypoints"][i][3].GetInt();
                                    if (speed < 5)
                                    {
                                        speed = -1;
                                    }
                                }
                                waypoint.speed = speed;
                                ai_waypoints.push_back(waypoint);
                            }
                        }
                    }
                }

                // Fetch additional presets, or display error if failed
                if (ai_presets_extern.Empty())
                {
                    if (ai_presets_extern_fetching)
                    {
                        float spinner_size = 8.f;
                        ImGui::SetCursorPosX((ImGui::GetWindowSize().x / 2.f) - spinner_size);
                        LoadingIndicatorCircle("spinner", spinner_size, theme.value_blue_text_color, theme.value_blue_text_color, 10, 10);
                    }
                    else if (ai_presets_extern_error != "")
                    {
                        ImGui::TextColored(RED_TEXT, "%s", _LC("TopMenubar", "Failed to fetch external presets."));
                        if (ImGui::Button(_LC("TopMenubar", "Retry")))
                        {
                            this->FetchExternAiPresetsOnBackground(); // Will post `MSG_NET_REFRESH_AI_PRESETS` when done.
                        }
                    }
                    else
                    {
                        this->FetchExternAiPresetsOnBackground(); // Will post `MSG_NET_REFRESH_AI_PRESETS` when done.
                    }
                }

                // If no presets found, display message
                if (display_count == 0 && !ai_presets_extern_fetching && ai_presets_extern_error == "")
                {
                    ImGui::Text("%s", _LC("TopMenubar", "No presets found for this terrain :("));
                    ImGui::Text("%s", _LC("TopMenubar", "Supported terrains:"));
                    ImGui::Separator();

                    ImGui::BeginChild("terrains-scrolling", ImVec2(0.f, 200), false);

                    for (size_t i = 0; i < num_rows; i++)
                    {
                        rapidjson::Value& j_row_terrains = ai_presets_all[static_cast<rapidjson::SizeType>(i)];
                        if (j_row_terrains.HasMember("terrains"))
                        {
                            for (size_t i = 0; i < j_row_terrains["terrains"].Size(); i++)
                            {
                                ImGui::Text("%s", j_row_terrains["terrains"][i].GetString());
                            }
                        }
                    }

                    ImGui::EndChild();
                }
            }

            if (ImGui::CollapsingHeader(_LC("TopMenubar", "Waypoints")))
            {
                if (ai_waypoints.empty())
                {
                    ImGui::Text("%s", _LC("TopMenubar", "No waypoints defined."));
                }
                else
                {
                    if (ImGui::Button(_LC("TopMenubar", "Export"), ImVec2(250, 0)))
                    {
                        std::string s;

                        for (int i = 0; i < ai_waypoints.size(); i++)
                        {
                            // Write position
                            s += "\n            [" + std::to_string(ai_waypoints[i].position.x) + ", " + std::to_string(ai_waypoints[i].position.y) + ", " + std::to_string(ai_waypoints[i].position.z);

                            // Write custom speed
                            if (ai_waypoints[i].speed >= 5)
                            {
                                s += ", " + std::to_string(ai_waypoints[i].speed);
                            }

                            // Close
                            s += "]";
                            if (i != ai_waypoints.size() - 1)
                            {
                                s += ",";
                            }
                        }

                        std::string json = fmt::format("\n    {{\n        \"terrain\":\"{}\",\n        \"preset\":\"Preset name\",\n        \"waypoints\":\n        [{}\n        ]\n    }}", App::sim_terrain_name->getStr(), s);
                        RoR::Log(json.c_str());

                        App::GetConsole()->putMessage(Console::CONSOLE_MSGTYPE_INFO, Console::CONSOLE_SYSTEM_NOTICE,
                                                      fmt::format(_LC("TopMenubar", "{} waypoints exported to RoR.log"),
                                                      ai_waypoints.size()), "lightbulb.png");
                    }

                    ImGui::BeginChild("waypoints-scrolling", ImVec2(0.f, 200), false);

                    for (int i = 0; i < ai_waypoints.size(); i++)
                    {
                        ImGui::PushID(i);
                        ImGui::AlignTextToFramePadding();
                        ImGui::Text("%d", i);
                        ImGui::SameLine();
                        if (ImGui::Button("teleport", ImVec2(60, 0)))
                        {
                            Ogre::Vector3* payload = new Ogre::Vector3(ai_waypoints[i].position);
                            App::GetGameContext()->PushMessage(Message(MSG_SIM_TELEPORT_PLAYER_REQUESTED, (void*)payload));
                        }
                        if (ImGui::IsItemHovered())
                        {
                            ImGui::BeginTooltip();
                            std::string w = "x:" + std::to_string(ai_waypoints[i].position.x) + " y:" + std::to_string(ai_waypoints[i].position.y) + " z:" + std::to_string(ai_waypoints[i].position.z);
                            ImGui::Text(w.c_str());
                            ImGui::EndTooltip();
                        }
                        ImGui::SameLine();
                        ImGui::SetNextItemWidth(90);

                        if (ai_waypoints[i].speed < -1)
                        {
                            ai_waypoints[i].speed = -1;
                        }
                        ImGui::InputInt(_LC("TopMenubar", "speed"), &ai_waypoints[i].speed, 1, 100);
                        if (ImGui::IsItemHovered())
                        {
                            ImGui::BeginTooltip();
                            ImGui::Text(_LC("TopMenubar", "Set waypoint speed in km/h for land vehicles"));
                            ImGui::Separator();
                            ImGui::Text(_LC("TopMenubar", "Value -1: Ignore, vehicle will use default speed"));
                            ImGui::Text(_LC("TopMenubar", "Value >= 5: Override default speed"));
                            ImGui::EndTooltip();
                        }
                        ImGui::PopID();
                    }

                    ImGui::EndChild();
                }
            }

            ImGui::PopItemWidth();
            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    case TopMenu::TOPMENU_TUNING:
        menu_pos.y = window_pos.y + tuning_cursor.y + MENU_Y_OFFSET;
        menu_pos.x = tuning_cursor.x + window_pos.x - ImGui::GetStyle().WindowPadding.x;
        ImGui::SetNextWindowPos(menu_pos);
        if (ImGui::Begin(_LC("TopMenubar", "Tuning menu"), nullptr, static_cast<ImGuiWindowFlags_>(flags)))
        {
            this->RefreshTuningMenu(); // make sure our local context is valid
            if (!tuning_actor)
            {
                ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
                ImGui::Text("%s", _LC("Tuning", "You are on foot."));
                ImGui::Text("%s", _LC("Tuning", "Enter a vehicle to tune it."));
                ImGui::PopStyleColor();
            }
            else
            {
                ROR_ASSERT(tuning_actor->getUsedActorEntry());
                TuneupDefPtr& tuneup_def = tuning_actor->getWorkingTuneupDef();

                // SAVED TUNEUPS
                ImGui::TextDisabled(fmt::format(_LC("Tuning", "Saved tuneups ({})"), tuning_saves.cqy_results.size()).c_str());
                for (CacheQueryResult& tuneup_result: tuning_saves.cqy_results)
                {
                    ImGui::PushID(tuneup_result.cqr_entry->fname.c_str());

                    ImGui::AlignTextToFramePadding();
                    ImGui::Bullet();

                    // Load button (with tuneup name)
                    ImGui::SameLine();
                    if (ImGui::Button(tuneup_result.cqr_entry->dname.c_str()))
                    {
                        ModifyProjectRequest* req = new ModifyProjectRequest();
                        req->mpr_type = ModifyProjectRequestType::PROJECT_LOAD_TUNEUP;
                        req->mpr_subject = tuneup_result.cqr_entry->fname;
                        req->mpr_target_actor = tuning_actor;
                        App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
                        // Why 'MODIFY_PROJECT_REQUESTED' for loading?
                        //  Instead of loading with the saved tuneup directly, we keep the autogenerated and sync it with the save.
                        //  That way, subsequent editing doesn't modify the save until user saves again.
                    }

                    // Delete button (right-aligned)
                    ImGui::SameLine();
                    if (tuning_rwidget_cursorx_min < ImGui::GetCursorPosX()) // Make sure button won't draw over item name
                        tuning_rwidget_cursorx_min = ImGui::GetCursorPosX();
                    std::string delbtn_text = _LC("Tuning", "Delete");
                    float delbtn_w = ImGui::CalcTextSize(delbtn_text.c_str()).x + ImGui::GetStyle().FramePadding.x * 2;
                    float delbtn_cursorx = ImGui::GetWindowContentRegionWidth() - delbtn_w;
                    if (delbtn_cursorx < tuning_rwidget_cursorx_min)
                        delbtn_cursorx = tuning_rwidget_cursorx_min;
                    ImGui::SetCursorPosX(delbtn_cursorx);
                    ImGui::PushStyleColor(ImGuiCol_Button, TUNING_HOLDTOCONFIRM_COLOR);
                    bool delbtn_pressed = RoR::ImButtonHoldToConfirm(delbtn_text, /*small:*/true, TUNING_HOLDTOCONFIRM_TIMELIMIT);
                    ImGui::PopStyleColor(); //ImGuiCol_Button
                    if (delbtn_pressed)
                    {
                        App::GetGameContext()->PushMessage(Message(MSG_EDI_DELETE_PROJECT_REQUESTED, new CacheEntryPtr(tuneup_result.cqr_entry)));
                    }

                    ImGui::PopID(); // tuneup_result.cqr_entry->fname.c_str()
                }

                // WORKING TUNEUP
                ImGui::Separator();
                ImGui::AlignTextToFramePadding();
                ImGui::TextDisabled(_LC("Tuning", "Working tuneup"));
                if (tuning_savebox_visible)
                {
                    ImGui::InputText(_LC("Tuning", "Name"), tuning_savebox_buf.GetBuffer(), tuning_savebox_buf.GetCapacity());

                    if (ImGui::Button(_LC("Tuning","Save")))
                    {
                        CreateProjectRequest* req = new CreateProjectRequest();
                        req->cpr_overwrite = tuning_savebox_overwrite;
                        req->cpr_type = CreateProjectRequestType::SAVE_TUNEUP;
                        req->cpr_source_actor = tuning_actor;
                        req->cpr_source_entry = tuning_actor->getUsedActorEntry();
                        req->cpr_name = tuning_savebox_buf.ToCStr();
                        App::GetGameContext()->PushMessage(Message(MSG_EDI_CREATE_PROJECT_REQUESTED, req));
                    }
                    ImGui::SameLine();
                    ImGui::Checkbox(_LC("Tuning", "Overwrite"), &tuning_savebox_overwrite);

                    // Cancel button (right-aligned)
                    if (tuning_rwidget_cursorx_min < ImGui::GetCursorPosX()) // Make sure button won't draw over save button
                        tuning_rwidget_cursorx_min = ImGui::GetCursorPosX();
                    std::string cancelbtn_text = _LC("Tuning", "Cancel");
                    float cancelbtn_w = ImGui::CalcTextSize(cancelbtn_text.c_str()).x + ImGui::GetStyle().FramePadding.x * 2;
                    float cancelbtn_cursorx = ImGui::GetWindowContentRegionWidth() - cancelbtn_w;
                    if (cancelbtn_cursorx < tuning_rwidget_cursorx_min)
                        cancelbtn_cursorx = tuning_rwidget_cursorx_min;
                    ImGui::SetCursorPosX(cancelbtn_cursorx);
                    if (ImGui::SmallButton(_LC("Tuning", "Cancel")))
                    {
                        tuning_savebox_visible = false;
                    }
                    ImGui::Separator();
                }
                else if (tuneup_def)
                {
                    ImGui::SameLine();
                    if (ImGui::Button(_LC("Tuning", "Save as...")))
                    {
                        tuning_savebox_visible = true;
                    }

                    // Reset button (right-aligned)
                    ImGui::SameLine();
                    if (tuning_rwidget_cursorx_min < ImGui::GetCursorPosX()) // Make sure button won't draw over save button
                        tuning_rwidget_cursorx_min = ImGui::GetCursorPosX();
                    ImGui::AlignTextToFramePadding();
                    std::string resetbtn_text = _LC("Tuning", "Reset");
                    float delbtn_w = ImGui::CalcTextSize(resetbtn_text.c_str()).x + ImGui::GetStyle().FramePadding.x * 2;
                    float delbtn_cursorx = ImGui::GetWindowContentRegionWidth() - delbtn_w;
                    if (delbtn_cursorx < tuning_rwidget_cursorx_min)
                        delbtn_cursorx = tuning_rwidget_cursorx_min;
                    ImGui::SetCursorPosX(delbtn_cursorx);
                    ImGui::PushStyleColor(ImGuiCol_Button, TUNING_HOLDTOCONFIRM_COLOR);
                    bool resetbtn_pressed = ImButtonHoldToConfirm(resetbtn_text, /*small:*/false, TUNING_HOLDTOCONFIRM_TIMELIMIT);
                    ImGui::PopStyleColor(); //ImGuiCol_Button
                    if (resetbtn_pressed)
                    {
                        ModifyProjectRequest* request = new ModifyProjectRequest();
                        request->mpr_target_actor = tuning_actor;
                        request->mpr_type = ModifyProjectRequestType::PROJECT_RESET_TUNEUP;
                        App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, request));
                    }
                }

                // ADDONPARTS

                ImGui::SetNextItemOpen(true, ImGuiCond_FirstUseEver);
                std::string addonparts_title = fmt::format(_LC("TopMenubar", "Addon parts ({})"), tuning_addonparts.size());
                if (ImGui::CollapsingHeader(addonparts_title.c_str()))
                {
                    for (size_t i = 0; i < tuning_addonparts.size(); i++)
                    {
                        const CacheEntryPtr& addonpart_entry = tuning_addonparts[i];

                        ImGui::PushID(addonpart_entry->fname.c_str());
                        const bool conflict_w_hovered = tuning_hovered_addonpart 
                            && (addonpart_entry != tuning_hovered_addonpart)
                            && AddonPartUtility::CheckForAddonpartConflict(tuning_hovered_addonpart, addonpart_entry, tuning_conflicts);
                        bool used = TuneupUtil::isAddonPartUsed(tuneup_def, addonpart_entry->fname);
                        const ImVec2 checkbox_cursor = ImGui::GetCursorScreenPos();
                        if (ImGui::Checkbox(addonpart_entry->dname.c_str(), &used) 
                            && !conflict_w_hovered
                            && !tuning_addonparts_conflict_w_used[i])
                        {
                            ModifyProjectRequest* req = new ModifyProjectRequest();
                            req->mpr_type = (used)
                                ? ModifyProjectRequestType::TUNEUP_USE_ADDONPART_SET
                                : ModifyProjectRequestType::TUNEUP_USE_ADDONPART_RESET;
                            req->mpr_subject = addonpart_entry->fname;
                            req->mpr_target_actor = tuning_actor;
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
                        }
                        // Draw conflict markers
                        if (tuning_addonparts_conflict_w_used[i])
                        {
                            // Gray-ish X inside the checkbox
                            const float square_sz = ImGui::GetFrameHeight();
                            const ImVec2 min = checkbox_cursor + ImGui::GetStyle().FramePadding*1.4f;
                            const ImVec2 max = checkbox_cursor + (ImVec2(square_sz, square_sz) - ImGui::GetStyle().FramePadding*1.5f);
                            const ImColor X_COLOR(0.5f, 0.48f, 0.45f);
                            ImGui::GetWindowDrawList()->AddLine(min, max, X_COLOR, 4.f);
                            ImGui::GetWindowDrawList()->AddLine(ImVec2(min.x, max.y), ImVec2(max.x, min.y), X_COLOR, 4.f);
                        }
                        if (conflict_w_hovered)
                        {
                            // Red unrounded square around the checkbox
                            const float square_sz = ImGui::GetFrameHeight();
                            const ImVec2 min = checkbox_cursor;
                            const ImVec2 max = checkbox_cursor + ImVec2(square_sz + 0.5f, square_sz);
                            const ImColor SQ_COLOR(0.7f, 0.1f, 0.f);
                            ImGui::GetWindowDrawList()->AddRect(min, max, SQ_COLOR, 0.f, ImDrawCornerFlags_None, 3.f);
                        }                        
                        // Record when checkbox is hovered - for drawing conflict markers
                        if (ImGui::IsItemHovered())
                        {
                            tuning_hovered_addonpart = addonpart_entry;
                        }
                        else if (tuning_hovered_addonpart == addonpart_entry)
                        {
                            tuning_hovered_addonpart = nullptr;
                        }
                        // Reload button (right-aligned)
                        ImGui::SameLine();
                        if (tuning_rwidget_cursorx_min < ImGui::GetCursorPosX()) // Make sure button won't draw over save button
                            tuning_rwidget_cursorx_min = ImGui::GetCursorPosX();
                        ImGui::AlignTextToFramePadding();
                        std::string reloadbtn_text = _LC("Tuning", "Reload");
                        const float reloadbtn_w = ImGui::CalcTextSize(reloadbtn_text.c_str()).x + ImGui::GetStyle().FramePadding.x * 2;
                        const float reloadbtn_cursorx = std::max(ImGui::GetWindowContentRegionWidth() - reloadbtn_w, tuning_rwidget_cursorx_min);
                        ImGui::SetCursorPosX(reloadbtn_cursorx);
                        const bool reloadbtn_pressed = ImGui::SmallButton(reloadbtn_text.c_str());
                        if (reloadbtn_pressed)
                        {
                            // Create spawn request while actor still exists
                            // Note we don't use `ActorModifyRequest::Type::RELOAD` because we don't need the bundle reloaded.
                            ActorSpawnRequest* srq = new ActorSpawnRequest;
                            srq->asr_position     = Ogre::Vector3(tuning_actor->getPosition().x, tuning_actor->getMinHeight(), tuning_actor->getPosition().z);
                            srq->asr_rotation     = Ogre::Quaternion(Ogre::Degree(270) - Ogre::Radian(tuning_actor->getRotation()), Ogre::Vector3::UNIT_Y);
                            srq->asr_config       = tuning_actor->getSectionConfig();
                            srq->asr_skin_entry   = tuning_actor->getUsedSkinEntry();
                            srq->asr_working_tuneup = tuning_actor->getWorkingTuneupDef();
                            srq->asr_cache_entry  = tuning_actor->getUsedActorEntry();
                            srq->asr_debugview    = (int)tuning_actor->GetGfxActor()->GetDebugView();
                            srq->asr_origin       = ActorSpawnRequest::Origin::USER;

                            // Request bundle reloading and chain the actor delete/spawn messages to it.
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_RELOAD_BUNDLE_REQUESTED, new CacheEntryPtr(addonpart_entry)));
                            App::GetGameContext()->ChainMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, new ActorPtr(tuning_actor)));
                            App::GetGameContext()->ChainMessage(Message(MSG_SIM_SPAWN_ACTOR_REQUESTED, srq));
                        }

                        ImGui::PopID(); //(addonpart_entry->fname.c_str());
                    }

                    if (ImGui::Button(_LC("Tuning", "Browse all parts")))
                    {
                        App::GetGameContext()->PushMessage(Message(MSG_GUI_OPEN_SELECTOR_REQUESTED, new LoaderType(LT_AddonPart)));                    
                    }

                    ImGui::Separator();
                }

                // Draw props
                size_t total_props = tuning_actor->GetGfxActor()->getProps().size();
                std::string props_title = fmt::format(_LC("Tuning", "Props ({})"), total_props);
                if (ImGui::CollapsingHeader(props_title.c_str()))
                {
                    // Draw all props (those removed by addonparts are also present as placeholders)
                    for (Prop const& p: tuning_actor->GetGfxActor()->getProps())
                    {
                        ImGui::PushID(p.pp_id);
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(p.pp_id);

                        this->DrawTuningForceRemoveControls(
                            p.pp_id,
                            p.pp_media[0],
                            tuneup_def && tuneup_def->isPropUnwanted(p.pp_id),
                            tuneup_def && tuneup_def->isPropForceRemoved(p.pp_id),
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_PROP_SET,
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_PROP_RESET);

                        // Draw special prop tooltip
                        if (p.pp_beacon_type == 'L' || p.pp_beacon_type == 'R' || p.pp_beacon_type == 'w')
                        {
                            ImGui::SameLine();
                            ImGui::TextDisabled("(special!)");
                            if (ImGui::IsItemHovered())
                            {
                                ImGui::BeginTooltip();
                                ImGui::Text("special prop - aerial nav light");
                                ImGui::EndTooltip();
                            }
                        }
                        else if (p.pp_wheel_mesh_obj)
                        {
                            ImGui::SameLine();
                            ImGui::TextDisabled("(special!)");
                            if (ImGui::IsItemHovered())
                            {
                                ImGui::BeginTooltip();
                                ImGui::Text("special prop - dashboard + dirwheel");
                                ImGui::EndTooltip();
                            }
                            
                        }

                        this->DrawTuningProtectedChkRightAligned(
                            p.pp_id,
                            tuneup_def && tuneup_def->isPropProtected(p.pp_id),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_PROP_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_PROP_RESET);

                        ImGui::PopID(); // p.pp_id
                    }

                    ImGui::Separator();
                }

                // Ditto for flexbodies
                size_t total_flexbodies = tuning_actor->GetGfxActor()->GetFlexbodies().size();
                std::string flexbodies_title = fmt::format(_LC("Tuning", "Flexbodies ({})"), total_flexbodies);
                if (ImGui::CollapsingHeader(flexbodies_title.c_str()))
                {
                    // Draw all flexbodies (those removed by addonparts are also present as placeholders)
                    for (FlexBody* flexbody: tuning_actor->GetGfxActor()->GetFlexbodies())
                    {
                        ImGui::PushID(flexbody->getID());
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(flexbody->getID());

                        this->DrawTuningForceRemoveControls(
                            flexbody->getID(),
                            flexbody->getOrigMeshName(),
                            tuneup_def && tuneup_def->isFlexbodyUnwanted(flexbody->getID()),
                            tuneup_def && tuneup_def->isFlexbodyForceRemoved(flexbody->getID()),
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLEXBODY_SET,
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLEXBODY_RESET);

                        this->DrawTuningProtectedChkRightAligned(
                            flexbody->getID(),
                            tuneup_def && tuneup_def->isFlexbodyProtected(flexbody->getID()),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_FLEXBODY_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_FLEXBODY_RESET);

                        ImGui::PopID(); // flexbody->getID()
                    }
                }

                // Draw wheels
                const int total_wheels = tuning_actor->ar_num_wheels;
                std::string wheels_title = fmt::format(_LC("TopMenubar", "Wheels ({})"), total_wheels);
                if (ImGui::CollapsingHeader(wheels_title.c_str()))
                {
                    for (WheelID_t i = 0; i < total_wheels; i++)
                    {
                        ImGui::PushID(i);
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(i);

                        // Draw R/L radio buttons
                        WheelSide forced_side = WheelSide::INVALID;
                        if (tuneup_def && tuneup_def->isWheelSideForced(i, /*[out]*/forced_side))
                        {
                            ImGui::PushStyleColor(ImGuiCol_Border, ORANGE_TEXT);
                            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.f);
                        }
                        const RoR::WheelSide active_side = TuneupUtil::getTweakedWheelSide(tuneup_def, i, tuning_actor->GetGfxActor()->getWheelSide(i));
                        RoR::WheelSide selected_side = active_side;
                        if (ImGui::RadioButton("##L", active_side == WheelSide::LEFT))
                            selected_side = WheelSide::LEFT;
                        ImGui::SameLine();
                        ImGui::TextDisabled("|");
                        ImGui::SameLine();
                        if (ImGui::RadioButton("##R", active_side == WheelSide::RIGHT))
                            selected_side = WheelSide::RIGHT;

                        // Draw rim mesh name
                        ImGui::SameLine();
                        ImGui::Text("%s", tuning_actor->GetGfxActor()->getWheelRimMeshName(i).c_str());

                        // Draw reset button

                        bool resetPressed = false;
                        if (tuneup_def && tuneup_def->isWheelSideForced(i, forced_side))
                        {
                            ImGui::SameLine();
                            ImGui::SameLine();
                            ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
                            resetPressed = ImGui::SmallButton(_LC("Tuning", "Reset"));
                            ImGui::PopStyleColor(); //ImGuiCol_Text, GRAY_HINT_TEXT
                            ImGui::PopStyleVar(); //ImGuiStyleVar_FrameBorderSize, 1.f
                            ImGui::PopStyleColor(); //ImGuiCol_Border, ORANGE_TEXT
                        }

                        // modify project if needed
                        if (selected_side != active_side)
                        {
                            ModifyProjectRequest* req = new ModifyProjectRequest();
                            req->mpr_type = ModifyProjectRequestType::TUNEUP_FORCED_WHEEL_SIDE_SET;
                            req->mpr_subject_id = i;
                            req->mpr_value_int = (int)selected_side;
                            req->mpr_target_actor = tuning_actor;
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));                        
                        }
                        else if (resetPressed)
                        {
                            ModifyProjectRequest* req = new ModifyProjectRequest();
                            req->mpr_type = ModifyProjectRequestType::TUNEUP_FORCED_WHEEL_SIDE_RESET;
                            req->mpr_subject_id = i;
                            req->mpr_target_actor = tuning_actor;
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
                        }

                        this->DrawTuningProtectedChkRightAligned(
                            i,
                            tuneup_def && tuneup_def->isWheelProtected(i),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_WHEEL_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_WHEEL_RESET);

                        ImGui::PopID(); // i
                    }
                }

                // Draw flares
                size_t total_flares = tuning_actor->ar_flares.size();
                std::string flares_title = fmt::format(_LC("Tuning", "Flares ({})"), total_flares);
                if (ImGui::CollapsingHeader(flares_title.c_str()))
                {
                    // Draw all flares (those removed by addonparts are also present as placeholders)
                    for (FlareID_t flareid = 0; flareid < (int)tuning_actor->ar_flares.size(); flareid++)
                    {
                        ImGui::PushID(flareid);
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(flareid);

                        // Compose flare description string
                        const FlareType flaretype = tuning_actor->ar_flares[flareid].fl_type;
                        std::string flarename;
                        if (flaretype == FlareType::USER)
                        {
                            int controlnumber = tuning_actor->ar_flares[flareid].controlnumber + 1; // Convert range 0-9 to 1-10
                            flarename = fmt::format("{} {}", (char)flaretype, controlnumber);
                        }
                        else if (flaretype == FlareType::DASHBOARD)
                        {
                            std::string linkname = tuning_actor->ar_dashboard->getLinkNameForID((DashData)tuning_actor->ar_flares[flareid].dashboard_link);
                            flarename = fmt::format("{} {}", (char)flaretype, linkname);
                        }
                        else
                        {
                            flarename = fmt::format("{}", (char)flaretype);
                        }

                        this->DrawTuningForceRemoveControls(
                            flareid,
                            flarename,
                            tuneup_def && tuneup_def->isFlareUnwanted(flareid),
                            tuneup_def && tuneup_def->isFlareForceRemoved(flareid),
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLARE_SET,
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_FLARE_RESET);

                        this->DrawTuningProtectedChkRightAligned(
                            flareid,
                            tuneup_def && tuneup_def->isFlareProtected(flareid),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_FLARE_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_FLARE_RESET);

                        ImGui::PopID(); // flareid
                    }
                }

                // Draw exhausts
                size_t total_exhausts = tuning_actor->GetGfxActor()->getExhausts().size();
                std::string exhausts_title = fmt::format(_LC("Tuning", "Exhausts ({})"), total_exhausts);
                if (ImGui::CollapsingHeader(exhausts_title.c_str()))
                {
                    // Draw all exhausts (those removed by addonparts are also present as placeholders)
                    for (ExhaustID_t exhaustid = 0; exhaustid < (int)total_exhausts; exhaustid++)
                    {
                        ImGui::PushID(exhaustid);
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(exhaustid);

                        this->DrawTuningForceRemoveControls(
                            exhaustid,
                            tuning_actor->GetGfxActor()->getExhausts()[exhaustid].particleSystemName,
                            tuneup_def && tuneup_def->isExhaustUnwanted(exhaustid),
                            tuneup_def && tuneup_def->isExhaustForceRemoved(exhaustid),
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_EXHAUST_SET,
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_EXHAUST_RESET);

                        this->DrawTuningProtectedChkRightAligned(
                            exhaustid,
                            tuneup_def && tuneup_def->isExhaustProtected(exhaustid),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_EXHAUST_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_EXHAUST_RESET);

                        ImGui::PopID(); // exhaustid
                    }
                }

                // Draw managed materials
                size_t total_materials = tuning_actor->ar_managed_materials.size();
                std::string materials_title = fmt::format(_LC("Tuning", "Managed Materials ({})"), total_materials);
                if (ImGui::CollapsingHeader(materials_title.c_str()))
                {
                    // Draw all materials (those removed by addonparts are also present as placeholders)
                    for (auto mm_pair: tuning_actor->ar_managed_materials)
                    {
                        const std::string& material_name = mm_pair.first;
                        ImGui::PushID(material_name.c_str());
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningForceRemoveControls(
                            TUNING_SUBJECTID_USE_NAME,
                            material_name,
                            tuneup_def && tuneup_def->isManagedMatUnwanted(material_name),
                            tuneup_def && tuneup_def->isManagedMatForceRemoved(material_name),
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_MANAGEDMAT_SET,
                            ModifyProjectRequestType::TUNEUP_FORCEREMOVE_MANAGEDMAT_RESET);

                        this->DrawTuningProtectedChkRightAligned(
                            TUNING_SUBJECTID_USE_NAME,
                            tuneup_def && tuneup_def->isManagedMatProtected(material_name),
                            ModifyProjectRequestType::TUNEUP_PROTECTED_MANAGEDMAT_SET,
                            ModifyProjectRequestType::TUNEUP_PROTECTED_MANAGEDMAT_RESET,
                            material_name);

                        ImGui::PopID(); // material_name.c_str()
                    }
                }

                // Draw videocameras
                size_t total_videocameras = tuning_actor->GetGfxActor()->getVideoCameras().size();
                std::string videocameras_title = fmt::format(_LC("Tuning", "Videocameras ({})"), total_videocameras);
                if (ImGui::CollapsingHeader(videocameras_title.c_str()))
                {
                    // Draw all videocameras (those removed by addonparts are also present as placeholders)
                    for (VideoCameraID_t videocameraid = 0; videocameraid < (int)total_videocameras; videocameraid++)
                    {
                        ImGui::PushID(videocameraid);
                        ImGui::AlignTextToFramePadding();

                        this->DrawTuningBoxedSubjectIdInline(videocameraid);

                        const VideoCamera& vcam = tuning_actor->GetGfxActor()->getVideoCameras()[videocameraid];

                        // Draw RTT material name
                        ImGui::SameLine();
                        ImGui::Dummy(ImVec2(3, 3));
                        ImGui::SameLine();
                        ImGui::Text("%s", tuning_actor->GetGfxActor()->getVideoCameras()[videocameraid].vcam_mat_name_orig.c_str());

                        // Setup the 'forced' state orange styling

                        VideoCamRole forced_role_def = VCAM_ROLE_INVALID;
                        if (tuneup_def && tuneup_def->isVideoCameraRoleForced(videocameraid, /*[out]*/forced_role_def))
                        {
                            ImGui::PushStyleColor(ImGuiCol_Border, ORANGE_TEXT);
                            ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.f);
                        }

                        // Draw the 'flipped' checkbox where applicable
                        const bool is_mirror_flip = vcam.vcam_role == VCAM_ROLE_MIRROR || vcam.vcam_role == VCAM_ROLE_TRACKING_MIRROR;
                        const bool is_mirror_noflip = vcam.vcam_role == VCAM_ROLE_MIRROR_NOFLIP || vcam.vcam_role == VCAM_ROLE_TRACKING_MIRROR_NOFLIP;
                        bool checkbox_pressed = false;
                        VideoCamRole desired_role = VCAM_ROLE_INVALID;
                        if ((is_mirror_flip || is_mirror_noflip))
                        {
                            ImGui::SameLine();
                            bool checkbox_checked = is_mirror_flip;
                            checkbox_pressed = ImGui::Checkbox(_LC("Tuning", "Flipped"), &checkbox_checked);
                            switch (vcam.vcam_role)
                            {
                            case VCAM_ROLE_MIRROR: desired_role = VCAM_ROLE_MIRROR_NOFLIP; break;
                            case VCAM_ROLE_MIRROR_NOFLIP: desired_role = VCAM_ROLE_MIRROR; break;
                            case VCAM_ROLE_TRACKING_MIRROR: desired_role = VCAM_ROLE_TRACKING_MIRROR_NOFLIP; break;
                            case VCAM_ROLE_TRACKING_MIRROR_NOFLIP: desired_role = VCAM_ROLE_TRACKING_MIRROR; break;
                            default: break;
                            }
                        }
                        else
                        {
                            // Inform user why this videocamera isn't flippable
                            ImGui::SameLine();
                            switch (vcam.vcam_role)
                            {
                            case VCAM_ROLE_MIRROR_PROP_LEFT: ImGui::TextDisabled(_LC("Tuning", "(Mirror prop - Left)")); break;
                            case VCAM_ROLE_MIRROR_PROP_RIGHT: ImGui::TextDisabled(_LC("Tuning", "(Mirror prop - Right)")); break;
                            default: ImGui::TextDisabled(_LC("Tuning", "(Videocamera)")); break;
                            }
                        }

                        // Draw reset button and reset the orange styling

                        bool reset_pressed = false;
                        if (tuneup_def && tuneup_def->isVideoCameraRoleForced(videocameraid, /*[out]*/forced_role_def))
                        {
                            ImGui::SameLine();
                            ImGui::SameLine();
                            ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
                            reset_pressed = ImGui::SmallButton(_LC("Tuning", "Reset"));
                            ImGui::PopStyleColor(); //ImGuiCol_Text, GRAY_HINT_TEXT
                            ImGui::PopStyleVar(); //ImGuiStyleVar_FrameBorderSize, 1.f
                            ImGui::PopStyleColor(); //ImGuiCol_Border, ORANGE_TEXT
                        }

                        // modify project if needed
                        if (checkbox_pressed)
                        {
                            ModifyProjectRequest* req = new ModifyProjectRequest();
                            req->mpr_type = ModifyProjectRequestType::TUNEUP_FORCED_VCAM_ROLE_SET;
                            req->mpr_subject_id = videocameraid;
                            req->mpr_value_int = (int)desired_role;
                            req->mpr_target_actor = tuning_actor;
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
                        }
                        else if (reset_pressed)
                        {
                            ModifyProjectRequest* req = new ModifyProjectRequest();
                            req->mpr_type = ModifyProjectRequestType::TUNEUP_FORCED_VCAM_ROLE_RESET;
                            req->mpr_subject_id = videocameraid;
                            req->mpr_target_actor = tuning_actor;
                            App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
                        }
                        

                        ImGui::PopID(); // videocameraid
                    }
                }
            }

            m_open_menu_hoverbox_min = menu_pos - MENU_HOVERBOX_PADDING;
            m_open_menu_hoverbox_max.x = menu_pos.x + ImGui::GetWindowWidth() + MENU_HOVERBOX_PADDING.x;
            m_open_menu_hoverbox_max.y = menu_pos.y + ImGui::GetWindowHeight() + MENU_HOVERBOX_PADDING.y;
            App::GetGuiManager()->RequestGuiCaptureKeyboard(ImGui::IsWindowHovered());
            ImGui::End();
        }
        break;

    default:
        m_open_menu_hoverbox_min = ImVec2(0,0);
        m_open_menu_hoverbox_max = ImVec2(0,0);
    }

    ImGui::PopStyleColor(2); // WindowBg, Button
}

bool TopMenubar::ShouldDisplay(ImVec2 window_pos)
{
    if (!App::GetGuiManager()->AreStaticMenusAllowed())
    {
        return false;
    }

    if (ImGui::IsMouseDown(1))
    {
        return false;
    }

    if (ai_menu)
    {
        m_open_menu = TopMenu::TOPMENU_AI;
        return true;
    }

    ImVec2 box_min(0,0);
    ImVec2 box_max(ImGui::GetIO().DisplaySize.x, ImGui::GetStyle().WindowPadding.y + PANEL_HOVERBOX_HEIGHT);
    ImVec2 mouse_pos = ImGui::GetIO().MousePos;
    const bool window_hovered ((mouse_pos.x >= box_min.x) && (mouse_pos.x <= box_max.x) &&
                            (mouse_pos.y >= box_min.y) && (mouse_pos.y <= box_max.y));
    bool result = window_hovered;

    bool menu_hovered = false;
    if (m_open_menu != TopMenu::TOPMENU_NONE)
    {
        menu_hovered = ((mouse_pos.x >= m_open_menu_hoverbox_min.x) && (mouse_pos.x <= m_open_menu_hoverbox_max.x) &&
                            (mouse_pos.y >= m_open_menu_hoverbox_min.y) && (mouse_pos.y <= m_open_menu_hoverbox_max.y));
    }
    result |= menu_hovered;

    bool box_hovered = false;
    if (m_state_box != StateBox::STATEBOX_NONE)
    {
        box_hovered = ((mouse_pos.x >= m_state_box_hoverbox_min.x) && (mouse_pos.x <= m_state_box_hoverbox_max.x) &&
                            (mouse_pos.y >= m_state_box_hoverbox_min.y) && (mouse_pos.y <= m_state_box_hoverbox_max.y));
        result |= box_hovered;
    }

    if (box_hovered && !menu_hovered)
    {
        m_open_menu = TopMenu::TOPMENU_NONE;
    }

    return result;
}

void TopMenubar::DrawMpUserToActorList(RoRnet::UserInfo &user)
{
    // Count actors owned by the player
    unsigned int num_actors_player = 0;
    for (ActorPtr& actor : App::GetGameContext()->GetActorManager()->GetActors())
    {
        if (actor->ar_net_source_id == user.uniqueid)
        {
            ++num_actors_player;
        }
    }

    // Display user in list
#ifdef USE_SOCKETW
    const Ogre::ColourValue player_color = App::GetNetwork()->GetPlayerColor(user.colournum);
    ImVec4 player_gui_color(player_color.r, player_color.g, player_color.b, 1.f);
    ImGui::PushStyleColor(ImGuiCol_Text, player_gui_color);
    ImGui::Text("%s: %u (%s, Ver: %s, Lang: %s)",
                user.username, num_actors_player,
                App::GetNetwork()->UserAuthToStringShort(user).c_str(),
                user.clientversion, user.language);
    ImGui::PopStyleColor();
#endif // USE_SOCKETW

    // Display actor list
    Ogre::TexturePtr tex1 = FetchIcon("control_pause.png");
    Ogre::TexturePtr tex2 = FetchIcon("control_play.png");
    int i = 0;
    for (ActorPtr& actor : App::GetGameContext()->GetActorManager()->GetActors())
    {
        if ((!actor->ar_hide_in_actor_list) && (actor->ar_net_source_id == user.uniqueid))
        {
            std::string id = fmt::format("{}:{}", i++, user.uniqueid);
            ImGui::PushID(id.c_str());
            if (actor->ar_state == ActorState::NETWORKED_OK)
            {
                if (ImGui::ImageButton(reinterpret_cast<ImTextureID>(tex1->getHandle()), ImVec2(16, 16)))
                {
                   App::GetGameContext()->PushMessage(Message(MSG_SIM_HIDE_NET_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                }
            }
            else if (actor->ar_state == ActorState::NETWORKED_HIDDEN)
            {
                if (ImGui::ImageButton(reinterpret_cast<ImTextureID>(tex2->getHandle()), ImVec2(16, 16)))
                {
                   App::GetGameContext()->PushMessage(Message(MSG_SIM_UNHIDE_NET_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                }
            }
            else // Our actor(s)
            {
                std::string text_buf_rem = fmt::format(" X ##[{}]", i);
                ImGui::PushStyleColor(ImGuiCol_Text, RED_TEXT);
                if (ImGui::Button(text_buf_rem.c_str()))
                {
                   App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
                }
                ImGui::PopStyleColor();
            }
            ImGui::PopID();
            ImGui::SameLine();

            std::string actortext_buf = fmt::format("{} ({}) ##[{}:{}]", StripColorMarksFromText(actor->ar_design_name).c_str(), actor->ar_filename.c_str(), i++, user.uniqueid);
            if (ImGui::Button(actortext_buf.c_str())) // Button clicked?
            {
                App::GetGameContext()->PushMessage(Message(MSG_SIM_SEAT_PLAYER_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
            }
        }
    }
}

void TopMenubar::DrawActorListSinglePlayer()
{
    std::vector<ActorPtr> actor_list;
    for (ActorPtr& actor : App::GetGameContext()->GetActorManager()->GetActors())
    {
        if (!actor->ar_hide_in_actor_list)
        {
            actor_list.emplace_back(actor);
        }
    }
    if (actor_list.empty())
    {
        ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
        ImGui::Text("%s", _LC("TopMenubar", "None spawned yet"));
        ImGui::Text("%s", _LC("TopMenubar", "Use [Simulation] menu"));
        ImGui::PopStyleColor();
    }
    else
    {
        ActorPtr player_actor = App::GetGameContext()->GetPlayerActor();
        int i = 0;
        for (ActorPtr& actor : actor_list)
        {
            std::string text_buf_rem = fmt::format("X ##[{}]", i);
            ImGui::PushStyleColor(ImGuiCol_Text, RED_TEXT);
            if (ImGui::Button(text_buf_rem.c_str()))
            {
                App::GetGameContext()->PushMessage(Message(MSG_SIM_DELETE_ACTOR_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
            }
            ImGui::PopStyleColor();
            ImGui::SameLine();

            std::string text_buf = fmt::format( "[{}] {}", i++, StripColorMarksFromText(actor->ar_design_name).c_str());
            if (actor == player_actor)
            {
                ImGui::PushStyleColor(ImGuiCol_Text, GREEN_TEXT);
            }
            else if (std::find(actor->ar_linked_actors.begin(), actor->ar_linked_actors.end(), player_actor) != actor->ar_linked_actors.end())
            {
                ImGui::PushStyleColor(ImGuiCol_Text, ORANGE_TEXT);
            }
            else if (actor->ar_state == ActorState::LOCAL_SIMULATED)
            {
                ImGui::PushStyleColor(ImGuiCol_Text, WHITE_TEXT);
            }
            else
            {
                ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
            }
            if (ImGui::Button(text_buf.c_str())) // Button clicked?
            {
                App::GetGameContext()->PushMessage(Message(MSG_SIM_SEAT_PLAYER_REQUESTED, static_cast<void*>(new ActorPtr(actor))));
            }
            ImGui::PopStyleColor();
        }
    }
}

void DrawRepairBoxEvent(events ev, std::string const& desc)
{
    ImDrawEventHighlighted(ev); ImGui::SameLine(); ImGui::TextDisabled(desc.c_str()); ImGui::NextColumn();
}

void DrawRepairBoxModkey(OIS::KeyCode modkey, std::string const& desc)
{
    ImDrawModifierKeyHighlighted(modkey); ImGui::SameLine(); ImGui::TextDisabled(desc.c_str()); ImGui::NextColumn();
}

void TopMenubar::DrawSpecialStateBox(float top_offset)
{
    float content_width = 0.f;
    // Always drawn on top:
    std::string special_text;
    ImVec4 special_color = ImGui::GetStyle().Colors[ImGuiCol_Text]; // Regular color
    float special_text_centering_weight = 1.f; // 0 = no centering
    // Only for race_box:
    std::string special_text_b;
    std::string special_text_c;
    std::string special_text_d;
    ImVec4 special_color_c = ImVec4(0,0,0,0);
    m_state_box = StateBox::STATEBOX_NONE;

    // Gather state info
    if (App::GetGameContext()->GetActorManager()->IsSimulationPaused() && !App::GetGuiManager()->IsGuiHidden())
    {
        special_color = ORANGE_TEXT;
        special_text = fmt::format(_LC("TopMenubar", "All physics paused, press {} to resume"),
                                   App::GetInputEngine()->getEventCommandTrimmed(EV_COMMON_TOGGLE_PHYSICS));
        content_width = ImGui::CalcTextSize(special_text.c_str()).x;
    }
    else if (App::GetGameContext()->GetPlayerActor() &&
             App::GetGameContext()->GetPlayerActor()->ar_physics_paused &&
             !App::GetGuiManager()->IsGuiHidden())
    {
        special_color = GREEN_TEXT;
        special_text = fmt::format(_LC("TopMenubar", "Vehicle physics paused, press {} to resume"),
                                   App::GetInputEngine()->getEventCommandTrimmed(EV_TRUCK_TOGGLE_PHYSICS));
        content_width = ImGui::CalcTextSize(special_text.c_str()).x;
    }
    else if (App::GetGameContext()->GetPlayerActor() &&
            App::GetGameContext()->GetPlayerActor()->ar_state == ActorState::LOCAL_REPLAY)
    {
        content_width = 300;
        m_state_box = StateBox::STATEBOX_REPLAY;
        special_text = _LC("TopMenubar", "Replay");
    }
    else if (App::GetGameContext()->GetRepairMode().IsLiveRepairActive())
    {
        special_text = fmt::format(_LC("TopMenubar", "Live repair mode, hit '{}' to stop"),
            App::GetInputEngine()->getEventCommandTrimmed(EV_COMMON_REPAIR_TRUCK));
        content_width = 450;
        m_state_box = StateBox::STATEBOX_LIVE_REPAIR;
        special_color = GREEN_TEXT;
        special_text_centering_weight = 0.7f;
    }
    else if (App::GetGameContext()->GetRepairMode().IsQuickRepairActive())
    {
        special_text = fmt::format(_LC("TopMenubar", "Quick repair ('{}' for Live repair)"),
            App::GetInputEngine()->getEventCommandTrimmed(EV_COMMON_LIVE_REPAIR_MODE));
        content_width = 450;
        m_state_box = StateBox::STATEBOX_QUICK_REPAIR;
        special_color = ORANGE_TEXT;
        special_text_centering_weight = 0.7f;
    }
    else if (App::GetGfxScene()->GetSimDataBuffer().simbuf_dir_arrow_visible)
    {
        m_state_box = StateBox::STATEBOX_RACE;

        // Calculate distance
        GameContextSB& data = App::GetGfxScene()->GetSimDataBuffer();
        GUIManager::GuiTheme const& theme = App::GetGuiManager()->GetTheme();
        float distance = 0.0f;
        ActorPtr player_actor = App::GetGfxScene()->GetSimDataBuffer().simbuf_player_actor;
        if (player_actor != nullptr && App::GetGameContext()->GetPlayerActor() &&
            player_actor->GetGfxActor()->GetSimDataBuffer().simbuf_actor_state == ActorState::LOCAL_SIMULATED)
        {
            distance = player_actor->GetGfxActor()->GetSimDataBuffer().simbuf_pos.distance(data.simbuf_dir_arrow_target);
        }
        else
        {
            distance = data.simbuf_character_pos.distance(data.simbuf_dir_arrow_target);
        }

        // format text
        special_text = App::GetGfxScene()->GetSimDataBuffer().simbuf_dir_arrow_text;
        special_text_b = fmt::format("{:.1f} {}", distance, _LC("DirectionArrow", "meter"));
        content_width = ImGui::CalcTextSize(special_text.c_str()).x + ImGui::CalcTextSize(special_text_b.c_str()).x;

        float time = App::GetGfxScene()->GetSimDataBuffer().simbuf_race_time;
        special_text_c = fmt::format("{:02d}.{:02d}.{:02d}", (int)(time) / 60, (int)(time) % 60, (int)(time * 100.0) % 100);
        float time_diff = App::GetGfxScene()->GetSimDataBuffer().simbuf_race_time_diff;
        special_color_c = (time_diff > 0.0f)
                          ? theme.value_red_text_color
                          : ((time_diff < 0.0f) ? theme.success_text_color : theme.value_blue_text_color);

        if (App::GetGfxScene()->GetSimDataBuffer().simbuf_race_best_time > 0.0f)
        {
            float best_time = App::GetGfxScene()->GetSimDataBuffer().simbuf_race_best_time;
            special_text_d = fmt::format("{:02d}.{:02d}.{:02d}", (int)(best_time) / 60, (int)(best_time) % 60, (int)(best_time * 100.0) % 100);
        }
    }
    else if (App::sim_state->getEnum<SimState>() == SimState::EDITOR_MODE)
    {
        special_color = GREEN_TEXT;
        special_text = fmt::format(_LC("TopMenubar", "Terrain editing mode, press {} to exit"),
            App::GetInputEngine()->getEventCommandTrimmed(EV_COMMON_TOGGLE_TERRAIN_EDITOR));

        if (App::GetGameContext()->GetTerrain()->getCacheEntry()->resource_bundle_type == "Zip")
        {
            // This is a read-only (ZIPped) terrain; offer the importer script.
            content_width = ImGui::CalcTextSize(special_text.c_str()).x + 25.f;
            m_state_box = StateBox::STATEBOX_IMPORT_TERRAIN;
        }
        else
        {
            special_text = fmt::format(_LC("TopMenubar", "Terrain editing mode, press {} to exit"),
                App::GetInputEngine()->getEventCommandTrimmed(EV_COMMON_TOGGLE_TERRAIN_EDITOR));
            content_width = ImGui::CalcTextSize(special_text.c_str()).x;
            m_state_box = StateBox::STATEBOX_OVERWRITE_TERRAIN;
        }
    }

    // Draw box if needed
    if (!special_text.empty())
    {
        ImVec2 box_pos;
        box_pos.y = top_offset;
        box_pos.x = (ImGui::GetIO().DisplaySize.x / 2) - ((content_width / 2) + ImGui::GetStyle().FramePadding.x);
        ImGui::SetNextWindowPos(box_pos);
        ImGui::SetNextWindowSize(ImVec2(0.f, 0.f));
        ImGui::SetNextWindowContentWidth(content_width);
        ImGuiWindowFlags flags = ImGuiWindowFlags_NoResize    | ImGuiWindowFlags_NoMove |
                                 ImGuiWindowFlags_NoTitleBar  | ImGuiWindowFlags_NoCollapse;
        ImGui::PushStyleColor(ImGuiCol_WindowBg, App::GetGuiManager()->GetTheme().semitransparent_window_bg);
        if (ImGui::Begin(special_text.c_str(), nullptr, flags))
        {
            if (m_state_box == StateBox::STATEBOX_LIVE_REPAIR || m_state_box == StateBox::STATEBOX_QUICK_REPAIR)
            {
                // Center the text, the box may be wider
                float text_w = ImGui::CalcTextSize(special_text.c_str()).x;
                ImGui::SetCursorPosX(((content_width / 2) - (text_w / 2)) * special_text_centering_weight);
            }
            ImGui::TextColored(special_color, "%s", special_text.c_str());

            if (m_state_box == StateBox::STATEBOX_REPLAY)
            {
                ImGui::SameLine();
                
                // Progress bar with frame index/count
                Replay* replay = App::GetGameContext()->GetPlayerActor()->getReplay();
                float fraction = (float)std::abs(replay->getCurrentFrame())/(float)replay->getNumFrames();
                Str<100> pbar_text; pbar_text << replay->getCurrentFrame() << "/" << replay->getNumFrames();
                float pbar_width = content_width - (ImGui::GetStyle().ItemSpacing.x + ImGui::CalcTextSize(special_text.c_str()).x);
                ImGui::ProgressBar(fraction, ImVec2(pbar_width, ImGui::GetTextLineHeight()), pbar_text.ToCStr());

                // Game time text
                float time_sec = replay->getLastReadTime() / 1000000.0;
                char str[200];
                int str_pos = 0;
                if (time_sec > 60)
                {
                    int min = (int)time_sec / 60;
                    str_pos = snprintf(str, 200, "%dmin ", min);
                    time_sec -= (float)min * 60.f;
                }
                snprintf(str+str_pos, 200-str_pos, "%.2fsec", time_sec);
                ImGui::TextDisabled("%s: %s", _LC("TopMenubar", "Time"), str);
                
            }
            else if (m_state_box == StateBox::STATEBOX_RACE)
            {
                ImGui::SameLine();
                ImGui::Text(special_text_b.c_str());
                ImGui::SetCursorPosX((ImGui::GetWindowSize().x / 2) - (ImGui::CalcTextSize(special_text_c.c_str()).x / 2));
                ImGui::TextColored(special_color_c,"%s", special_text_c.c_str());

                Str<300> text;
                text << "Best Time: " << special_text_d.c_str();
                ImGui::SetCursorPosX((ImGui::GetWindowSize().x / 2) - (ImGui::CalcTextSize(text).x / 2));

                if (!special_text_d.empty())
                {
                    ImGui::TextDisabled(text);
                }
            }
            else if (m_state_box == StateBox::STATEBOX_LIVE_REPAIR || m_state_box == StateBox::STATEBOX_QUICK_REPAIR)
            {
                // Draw special element on the right
                ImGui::SameLine();
                ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2.f, 0.f));
                if (m_state_box == StateBox::STATEBOX_QUICK_REPAIR && App::sim_live_repair_interval->getFloat() > 0)
                {
                    const float fraction = App::GetGameContext()->GetRepairMode().GetLiveRepairTimer() / App::sim_live_repair_interval->getFloat();
                    ImGui::ProgressBar(fraction, ImVec2(15.f, ImGui::GetTextLineHeight() / 2.f), "");
                    ImGui::SameLine();
                }
                DrawGCheckbox(App::ui_show_live_repair_controls, _LC("LiveRepair", "Show controls"));
                ImGui::PopStyleVar(); // FramePadding

                const ImVec2 MINI_SPACING = ImVec2(2.f,0.f);
                ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, MINI_SPACING);

                if (App::ui_show_live_repair_controls->getBool())
                {
                    const float INDENT = 15.f;
                    ImGui::Separator();
                    ImGui::TextDisabled("%s:", _LC("LiveRepair", "Movement"));
                      ImGui::Columns(3);
                      ImGui::SetColumnWidth(0, INDENT);
                        ImGui::NextColumn();
                        DrawRepairBoxEvent(EV_CHARACTER_FORWARD,_LC("LiveRepair", "Forward"));
                        DrawRepairBoxEvent(EV_CHARACTER_BACKWARDS,_LC("LiveRepair", "Backward"));
                        ImGui::NextColumn();
                        DrawRepairBoxEvent(EV_CHARACTER_SIDESTEP_LEFT,_LC("LiveRepair", "Left"));
                        DrawRepairBoxEvent(EV_CHARACTER_SIDESTEP_RIGHT,_LC("LiveRepair", "Right"));
                        ImGui::NextColumn();
                        DrawRepairBoxEvent(EV_TRUCK_ACCELERATE,_LC("LiveRepair", "Up"));
                        DrawRepairBoxEvent(EV_TRUCK_BRAKE,_LC("LiveRepair", "Down"));
                      ImGui::Columns(1);

                    ImGui::TextDisabled("%s:", _LC("LiveRepair", "Rotation"));
                      ImGui::Columns(3);
                      ImGui::SetColumnWidth(0, INDENT);
                        ImGui::NextColumn();
                        DrawRepairBoxEvent(EV_TRUCK_STEER_LEFT,_LC("LiveRepair", "Rot. left"));
                        DrawRepairBoxEvent(EV_TRUCK_STEER_RIGHT,_LC("LiveRepair", "Rot. right"));
                      ImGui::Columns(1);

                    ImGui::TextDisabled("%s:", _LC("LiveRepair", "Modifiers"));
                      ImGui::Columns(4);
                      ImGui::SetColumnWidth(0, INDENT);
                      ImGui::SetColumnWidth(1, 125);
                      ImGui::SetColumnWidth(2, 125);
                        ImGui::NextColumn();
                        DrawRepairBoxModkey(OIS::KC_LMENU,_LC("LiveRepair", "Slow step")); // Left alt
                        DrawRepairBoxModkey(OIS::KC_LSHIFT,_LC("LiveRepair", "Fast step"));
                        DrawRepairBoxModkey(OIS::KC_LCONTROL,_LC("LiveRepair", "10x step")); // Left ctrl
                      ImGui::Columns(1);

                    SimResetMode resetmode = App::sim_soft_reset_mode->getEnum<SimResetMode>();
                    ImGui::TextDisabled("%s (%s):", _LC("LiveRepair", "Reset mode"), ToLocalizedString(resetmode).c_str());
                      ImGui::Dummy(ImVec2(INDENT, 1.f));
                      ImGui::SameLine();
                      DrawRepairBoxEvent(EV_COMMON_TOGGLE_RESET_MODE,_LC("LiveRepair", "Switch reset mode"));
                }
                ImGui::PopStyleVar(); // ItemSpacing
            }
            else if (m_state_box == StateBox::STATEBOX_IMPORT_TERRAIN)
            {
                ImGui::Separator();
                // notice text
                std::string lbl_readonly = _LC("TopMenubar", "This terrain is read only.");
                ImGui::SetCursorPosX(ImGui::GetCursorPosX()
                    + (ImGui::GetWindowContentRegionWidth() / 2 - ImGui::CalcTextSize(lbl_readonly.c_str()).x/2));
                ImGui::TextDisabled("%s", lbl_readonly.c_str());
                // import button
                ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.2, 0.2, 0.2, 1.0));
                std::string btn_import = _LC("TopMenubar", "Import as editable project.");
                ImGui::SetCursorPosX(ImGui::GetCursorPosX()
                    + ((ImGui::GetWindowContentRegionWidth() / 2 - ImGui::CalcTextSize(btn_import.c_str()).x / 2) - ImGui::GetStyle().FramePadding.x));
                if (!m_terrn_import_started && ImGui::Button(btn_import.c_str()))
                {
                    RoR::LoadScriptRequest* rq = new LoadScriptRequest();
                    rq->lsr_filename = "terrain_project_importer.as";
                    rq->lsr_category = ScriptCategory::CUSTOM;
                    App::GetGameContext()->PushMessage(Message(MSG_APP_LOAD_SCRIPT_REQUESTED, rq));
                    m_terrn_import_started = true;
                }
                ImGui::PopStyleColor(); // ImGuiCol_Button
            }
            else if (m_state_box == StateBox::STATEBOX_OVERWRITE_TERRAIN)
            {
                // Info text
                std::string lbl_usemenu = _LC("TopMenubar", "Use 'Simulation' menu to save changes.");
                ImGui::SetCursorPosX(ImGui::GetCursorPosX()
                    + (ImGui::GetWindowContentRegionWidth() / 2 - ImGui::CalcTextSize(lbl_usemenu.c_str()).x / 2));
                ImGui::TextDisabled("%s", lbl_usemenu.c_str());
            }
            const ImVec2 PAD = ImVec2(5, 5); // To bridge top menubar hoverbox and statebox hoverbox
            m_state_box_hoverbox_min = box_pos - PAD;
            m_state_box_hoverbox_max.x = box_pos.x + ImGui::GetWindowWidth();
            m_state_box_hoverbox_max.y = box_pos.y + ImGui::GetWindowHeight();
            m_state_box_hoverbox_max += PAD;
            // DO NOT `RequestGuiCaptureKeyboard()` - we want to use the hotkeys through it.
            ImGui::End();
        }
        ImGui::PopStyleColor(1); // WindowBg
    }

    if (App::sim_state->getEnum<SimState>() != SimState::EDITOR_MODE)
    {
        m_terrn_import_started = false;
    }
}

void TopMenubar::LoadBundledAiPresets(TerrainPtr terrain)
{
    // Load 'bundled' AI presets - see section `[AI Presets]` in terrn2 file format
    // ----------------------------------------------------------------------------

    App::GetGuiManager()->TopMenubar.ai_presets_bundled.SetArray();

    for (const std::string& filename: terrain->GetDef()->ai_presets_files)
    {
        rapidjson::Document j_doc;
        if (Ogre::ResourceGroupManager::getSingleton().resourceExists(terrain->getTerrainFileResourceGroup(), filename))
        {
            App::GetContentManager()->LoadAndParseJson(filename, terrain->getTerrainFileResourceGroup(), j_doc);
        }
        else
        {
            LOG(fmt::format("[RoR|Terrain] AI presets file '{}' declared in '{}' not found!", filename, terrain->getTerrainFileName()));
        }

        // Ensure the format is about right
        if (!j_doc.IsArray())
        {
            LOG(fmt::format("[RoR|Terrain] AI presets file '{}' declared in '{}' has wrong format - the root element is not an array!",
                    filename, terrain->getTerrainFileName()));
        }
        else
        {
            // Finally add the presets to the list
            for (const rapidjson::Value& j_bundled_preset: j_doc.GetArray())
            {
                rapidjson::Value preset_copy(j_bundled_preset, App::GetGuiManager()->TopMenubar.ai_presets_bundled.GetAllocator());
                App::GetGuiManager()->TopMenubar.ai_presets_bundled.PushBack(preset_copy, App::GetGuiManager()->TopMenubar.ai_presets_bundled.GetAllocator());
            }
        }
    }

    App::GetGuiManager()->TopMenubar.RefreshAiPresets();
}

void TopMenubar::FetchExternAiPresetsOnBackground()
{
#if defined(USE_CURL)
    std::packaged_task<void()> task(FetchAiPresetsThreadFunc);
    std::thread(std::move(task)).detach();
    ai_presets_extern_fetching = true;
#endif // defined(USE_CURL)
}

void TopMenubar::RefreshAiPresets()
{
    // Combine external and bundled presets into one JSON doc
    // -------------------------------------------------------

    ai_presets_all.Clear();
    ai_presets_all.SetArray();

    for (rapidjson::Value& bundled_preset: ai_presets_bundled.GetArray())
    {
        rapidjson::Value preset_copy(bundled_preset, ai_presets_all.GetAllocator());
        ai_presets_all.PushBack(preset_copy, ai_presets_all.GetAllocator());
    }

    for (const rapidjson::Value& extern_preset: ai_presets_extern.GetArray())
    {
        rapidjson::Value preset_copy(extern_preset, ai_presets_all.GetAllocator());
        ai_presets_all.PushBack(preset_copy, ai_presets_all.GetAllocator());
    }
}

void TopMenubar::RefreshTuningMenu()
{
    // Updates/resets the tuning menu for the current vehicle driven by player (if any).
    // -------------------------------------------------------------------------------

    if (App::sim_tuning_enabled->getBool() 
        && (App::mp_state->getEnum<MpState>() != MpState::CONNECTED)
        && App::GetGameContext()->GetPlayerActor() 
        && (tuning_actor != App::GetGameContext()->GetPlayerActor()))
    {
        tuning_actor = App::GetGameContext()->GetPlayerActor();
        ROR_ASSERT(tuning_actor->getUsedActorEntry());

        tuning_addonparts.clear();
        tuning_saves.resetResults();

        // Addonparts matched by GUID
        if (tuning_actor->getUsedActorEntry()->guid != "")
        {
            CacheQuery query_addonparts;
            query_addonparts.cqy_filter_type = LT_AddonPart;
            query_addonparts.cqy_filter_guid = tuning_actor->getUsedActorEntry()->guid;
            query_addonparts.cqy_filter_target_filename = tuning_actor->getTruckFileName(); // Addonparts without any filenames listed will just pass.
            App::GetCacheSystem()->Query(query_addonparts);
            for (CacheQueryResult& res: query_addonparts.cqy_results)
            {
                tuning_addonparts.push_back(res.cqr_entry);
            }
        }

        // Addonparts force-installed via [browse all] button; watch for duplicates.
        if (tuning_actor->getWorkingTuneupDef())
        {
            for (std::string const& use_addonpart_fname: tuning_actor->getWorkingTuneupDef()->use_addonparts)
            {
                CacheEntryPtr entry = App::GetCacheSystem()->FindEntryByFilename(LT_AddonPart, /*partial:*/false, use_addonpart_fname);
                if (entry)
                {
                    if (std::find(tuning_addonparts.begin(), tuning_addonparts.end(), entry) == tuning_addonparts.end())
                    {
                        tuning_addonparts.push_back(entry);
                    }
                }
            }
        }

        tuning_saves.cqy_filter_type = LT_Tuneup;
        tuning_saves.cqy_filter_guid = tuning_actor->getUsedActorEntry()->guid;
        tuning_saves.cqy_filter_target_filename = tuning_actor->getTruckFileName();
        tuning_saves.cqy_filter_category_id = CID_Tuneups; // Exclude auto-generated entries
        tuning_saves.resetResults();
        App::GetCacheSystem()->Query(tuning_saves);

        // Refresh `tuning_conflicts` database ~ test eligible addonparts each with each once.
        tuning_conflicts.clear();
        for (size_t i1 = 0; i1 < tuning_addonparts.size(); i1++)
        {
            for (size_t i2 = i1; i2 < tuning_addonparts.size(); i2++)
            {
                if (i1 != i2)
                {
                    AddonPartUtility::RecordAddonpartConflicts(tuning_addonparts[i1], tuning_addonparts[i2], tuning_conflicts);
                }
            }
        }

        // Refresh `tuning_addonparts_conflicting` listing ~ test used addonparts against unused.
        tuning_addonparts_conflict_w_used.clear();
        tuning_addonparts_conflict_w_used.resize(tuning_addonparts.size(), false);
        if (tuning_actor->getWorkingTuneupDef())
        {
            for (const std::string& use_addonpart_fname: tuning_actor->getWorkingTuneupDef()->use_addonparts)
            {
                CacheEntryPtr use_addonpart_entry = App::GetCacheSystem()->FindEntryByFilename(LT_AddonPart, /*partial:*/false, use_addonpart_fname);
                for (size_t i = 0; i < tuning_addonparts.size(); i++)
                {
                    if (tuning_addonparts[i] != use_addonpart_entry)
                    {
                        tuning_addonparts_conflict_w_used[i] = tuning_addonparts_conflict_w_used[i]
                            || AddonPartUtility::CheckForAddonpartConflict(tuning_addonparts[i], use_addonpart_entry, tuning_conflicts);
                    }
                }
            }
        }

        tuning_rwidget_cursorx_min = 0.f;
    }
    else if (!App::sim_tuning_enabled->getBool() || !App::GetGameContext()->GetPlayerActor())
    {
        tuning_addonparts.clear();
        tuning_saves.resetResults();
        tuning_actor = nullptr;
    }
}

void TopMenubar::DrawTuningProtectedChkRightAligned(const int subject_id, bool protectchk_value, ModifyProjectRequestType request_type_set,  ModifyProjectRequestType request_type_reset, const std::string& subject /* ="" */)
{
    // > resolve the alignment
    ImGui::SameLine();
    if (tuning_rwidget_cursorx_min < ImGui::GetCursorPosX()) // Make sure button won't draw over item name
        tuning_rwidget_cursorx_min = ImGui::GetCursorPosX();
    std::string protectchk_text = _LC("Tuning", "Protected");
    float protectchk_w = ImGui::CalcTextSize(protectchk_text.c_str()).x + ImGui::GetStyle().FramePadding.x * 2;
    float protectchk_cursorx = (ImGui::GetWindowContentRegionWidth() - protectchk_w) - 20.f;
    if (protectchk_cursorx < tuning_rwidget_cursorx_min)
        protectchk_cursorx = tuning_rwidget_cursorx_min;
    ImGui::SetCursorPosX(protectchk_cursorx);

    // > set styling and draw
    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0.0f, 0.0f));
    bool chk_pressed = ImGui::Checkbox(protectchk_text.c_str(), &protectchk_value);
    ImGui::PopStyleVar(1); // ImGuiStyleVar_FramePadding
    
    // > handle user action
    if (chk_pressed)
    {
        ModifyProjectRequest* request = new ModifyProjectRequest();
        request->mpr_target_actor = tuning_actor;
        if (subject_id == TUNING_SUBJECTID_USE_NAME)
        {
            request->mpr_subject = subject;
        }
        else
        {
            request->mpr_subject_id = subject_id;
        }
        request->mpr_type = (protectchk_value) ? request_type_set : request_type_reset;
        App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, request));
    }
}

void TopMenubar::DrawTuningBoxedSubjectIdInline(int subject_id)
{
    // Draw subject ID in outlined box
    // -------------------------------
    ImGui::GetWindowDrawList()->AddRect(
        ImGui::GetCursorScreenPos(), 
        ImGui::GetCursorScreenPos() + ImGui::CalcTextSize("00") + ImGui::GetStyle().FramePadding*2,
        ImColor(ImGui::GetStyle().Colors[ImGuiCol_TextDisabled]),
        ImGui::GetStyle().FrameRounding);
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetStyle().FramePadding.x);
    ImGui::Text("%02d", subject_id);
    ImGui::SameLine();
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetStyle().FramePadding.x); 
}

void TopMenubar::DrawTuningForceRemoveControls(const int subject_id, const std::string& name, const bool is_unwanted, const bool is_force_removed, ModifyProjectRequestType request_type_set,  ModifyProjectRequestType request_type_reset)
{
    // Common for props and flexbodies: draws the force-remove checkbox and the reset button
    // ------------------------------------------------------------------------------------

    // Draw the checkbox for force-removing.
    bool isEnabled = !is_unwanted && !is_force_removed;
    if (is_force_removed)
    {
        ImGui::PushStyleColor(ImGuiCol_Border, ORANGE_TEXT);
        ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.f);
    }
    bool chkPressed = ImGui::Checkbox(name.c_str(), &isEnabled);
    bool resetPressed = false;
    if (is_force_removed)
    {
        ImGui::SameLine();
        ImGui::PushStyleColor(ImGuiCol_Text, GRAY_HINT_TEXT);
        resetPressed = ImGui::SmallButton(_LC("Tuning", "Reset"));
        ImGui::PopStyleColor(); //ImGuiCol_Text, GRAY_HINT_TEXT
        ImGui::PopStyleVar(); //ImGuiStyleVar_FrameBorderSize, 1.f
        ImGui::PopStyleColor(); //ImGuiCol_Border, ORANGE_TEXT
    }

    // perform project modification if needed
    if (chkPressed && !isEnabled)
    {
        ModifyProjectRequest* req = new ModifyProjectRequest();
        req->mpr_type = request_type_set;
        if (subject_id == TUNING_SUBJECTID_USE_NAME)
        {
            req->mpr_subject = name;
        }
        else
        {
            req->mpr_subject_id = subject_id;
        }
        req->mpr_target_actor = tuning_actor;
        App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
    }
    else if ((chkPressed && isEnabled) || resetPressed)
    {
        ModifyProjectRequest* req = new ModifyProjectRequest();
        req->mpr_type = request_type_reset;
        if (subject_id == TUNING_SUBJECTID_USE_NAME)
        {
            req->mpr_subject = name;
        }
        else
        {
            req->mpr_subject_id = subject_id;
        }
        req->mpr_target_actor = tuning_actor;
        App::GetGameContext()->PushMessage(Message(MSG_EDI_MODIFY_PROJECT_REQUESTED, req));
    }

}

bool TopMenubar::IsMenuEnabled(TopMenu which)
{
    switch (which)
    {
    case TopMenu::TOPMENU_AI:
        return App::mp_state->getEnum<MpState>() != MpState::CONNECTED;
    case TopMenu::TOPMENU_TUNING:
        return App::sim_tuning_enabled->getBool() && (App::mp_state->getEnum<MpState>() != MpState::CONNECTED);
    default:
        return true;
    }
}
